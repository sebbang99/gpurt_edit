/* Copyright (c) 2022-2023 Advanced Micro Devices, Inc. All rights reserved. */

// ============================================================================
// WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!  WARNING!
//
// This code was auto-generated by settings_codegen.py. Do not modify manually.
// ============================================================================

#pragma once

#include <dd_settings_base.h>
#include <dd_settings_blob.h>
#include <dd_optional.h>

#include <pal.h>

#include <palImage.h>

typedef Util::uint64 uint64;
typedef Util::uint32 uint32;
typedef Util::uint8 uint8;
typedef Pal::gpusize gpusize;

namespace vk
{


/// Enums /////////////////////////////////////////////////////////////////////
enum FeatureEnableMode :  uint32_t 
{
    FeatureDefault = 0x0, // Default, use application setting
    FeatureForceEnable = 0x1, // Force Enable
    FeatureForceDisable = 0x2, // Force Disable Default Value
};

enum OptRenderStateCacheFlag :  uint32_t 
{
    OptRenderStateCacheMsaaState = 0x1, // PAL MSAA state objects (all graphics pipelines)
    OptRenderStateCacheColorBlendState = 0x2, // PAL color blend state objects (all graphics pipelines)
    OptRenderStateCacheDepthStencilState = 0x4, // PAL depth stencil state objects (all graphics pipelines)
    OptRenderStateCacheInputAssemblyState = 0x8, // PAL input assembly state params (all graphics pipelines)
    OptRenderStateCacheTriangleRasterState = 0x10, // Triangle raster state params (part of every graphics pipeline)
    OptRenderStateCacheStaticPointLineRasterState = 0x20, // Point line raster state (only when marked static)
    OptRenderStateCacheStaticDepthBias = 0x40, // Depth bias state (only when marked static)
    OptRenderStateCacheStaticBlendConst = 0x80, // Blend const state (only when marked static)
    OptRenderStateCacheStaticDepthBounds = 0x100, // Depth bounds state (only when marked static)
    OptRenderStateCacheStaticViewport = 0x200, // Viewport state (only when marked static)
    OptRenderStateCacheStaticScissorRect = 0x400, // Scissor rect state (only when marked static)
    OptRenderStateCacheStaticGraphicsWaveLimits = 0x800, // Graphics wave limits state (only when marked static)
    OptRenderStateCacheStaticComputeWaveLimits = 0x1000, // Compute wave limits state (only when marked static)
    OptRenderStateCacheStaticAnisoLodCompensation = 0x2000, // Aniso LOD compensation state (only when marked static)
    OptRenderStateCacheStaticLineStipple = 0x4000, // Line stipple state (only when marked static)
    OptRenderStateFragmentShadingRate = 0x8000, // Variable Rate Shading
};

enum InvariantLoads :  uint32_t 
{
    Auto = 0x0, 
    EnableOptimization = 0x1, 
    DisableOptimization = 0x2, 
    ClearInvariants = 0x3, 
};

enum PipelineBinningMode :  uint32_t 
{
    PipelineBinningModeDefault = 0x0, // 'Default' follows the PBB global setting.
    PipelineBinningModeDisable = 0x1, // 'Disable' disables pipeline binning.
    PipelineBinningModeEnable = 0x2, // 'Enable' enables pipeline binning.
};

enum GraphicsPipelineType :  uint32_t 
{
    GraphicsPipelineTypeVsFs = 0x1, // VS PS pipelines
    GraphicsPipelineTypeGs = 0x2, // VS GS PS pipelines
    GraphicsPipelineTypeTess = 0x4, // Tess pipelines without GS
    GraphicsPipelineTypeTessGs = 0x8, // Tess pipeline with GS
};

#if VKI_RAY_TRACING
enum BvhBuildMode :  uint32_t 
{
    BvhBuildModeLinear = 0x0, // Use linear BVH builder
    BvhBuildModePLOC = 0x2, // Use parallel locally-ordered clustering BVH builder
    BvhBuildModeAuto = 0x4, // Only for override builds. If set, falls back to regular build options.
};
#endif

enum ThreadGroupSwizzleMode :  uint32_t 
{
    ThreadGroupSwizzleModeDefault = 0x0, // Use default shader settings
    ThreadGroupSwizzleMode4x4 = 0x1, // Swizzle thread groups with 4x4 tiles
    ThreadGroupSwizzleMode8x8 = 0x2, // Swizzle thread groups with 8x8 tiles
    ThreadGroupSwizzleMode16x16 = 0x3, // Swizzle thread groups with 16x16 tiles
};

enum HwPipePoint :  uint32_t 
{
    HwPipeTop = 0x0, // Same as HwPipePreIndexBuffer
    HwPipePostPrefetch = 0x1, // Same as HwPipePreCs for compute-specific work or HwPipePreBlt for BLT-specific work
    HwPipePreRasterization = 0x2, // Same as HwPipePostIndexBuffer
    HwPipePostPs = 0x3, 
    HwPipePreColorTarget = 0x4, 
    HwPipePostCs = 0x5, 
    HwPipePostBlt = 0x6, 
    HwPipeBottom = 0x7, 
};

enum PalCacheCoherencyFlags :  uint32_t 
{
    CoherCpu = 0x1, 
    CoherShaderRead = 0x2, 
    CoherShaderWrite = 0x4, 
    CoherCopySrc = 0x8, 
    CoherCopyDst = 0x10, 
    CoherColorTarget = 0x20, 
    CoherDepthStencilTarget = 0x40, 
    CoherResolveSrc = 0x80, 
    CoherResolveDst = 0x100, 
    CoherClear = 0x200, 
    CoherIndirectArgs = 0x400, 
    CoherIndexData = 0x800, 
    CoherQueueAtomic = 0x1000, 
    CoherTimestamp = 0x2000, 
    CoherCeLoad = 0x4000, 
    CoherCeDump = 0x8000, 
    CoherStreamOut = 0x10000, 
    CoherMemory = 0x20000, 
    CoherSampleRate = 0x40000, 
    CoherPresent = 0x80000, 
    CoherAllUsages = 0x1FFFFF, // (heavyweight option)
};

enum CacheUuidNamespace :  uint32_t 
{
    CacheUuidNamespaceDefault = 0x0, // Use the default namespace for the platform.
    CacheUuidNamespaceGlobal = 0x1, // Force usage of a global (portable) scope.
    CacheUuidNamespaceLocal = 0x2, // Force usage of a local (non-portable) scope.
};

enum PipelineFastCompileMode :  uint32_t 
{
    PipelineFastCompileApiControlled = 0x0, // Full optimzimization is disabled (optLevel = C1 or C0 dependent on compiler) if VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is set. and optLevel = C2 if VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT is not set
    PipelineFastCompileNeverOptimized = 0x1, // Disable all optimizization to enable fast compile. i.e. Force optLevel = C0.
    PipelineFastCompileFastOptimized = 0x2, // Disable most optimziation to optimize compile. i.e. Force optLevel = C1.
    PipelineFastCompileFullOptimized = 0x3, // Force to do full optimziation. i.e. Force optLevel = C2.
};

enum PipelineLinkOptimizationMode :  uint32_t 
{
    PipelineLinkOptimizationApiControlled = 0x0, // Use VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT set by API
    PipelineLinkOptimizationNeverOptimized = 0x1, // Force flag VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0
    PipelineLinkOptimizationAlwaysOptimized = 0x2, // Force flag VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 1.
};

enum PipelineLayoutMode :  uint32_t 
{
    PipelineLayoutDefault = 0x0, // Build descritptor layout with default layout
    PipelineLayoutAngle = 0x1, // Build descriptor layout compatible with angle base app
};

enum PipelineLayoutSchemeSelectionStrategy :  uint32_t 
{
    AppControlled = 0x0, // The scheme is decided by user
    ForceCompact = 0x1, // Always use compact scheme
    ForceIndirect = 0x2, // Always use indirect scheme
};

enum DisableBinningPsKill :  uint32_t 
{
    DisableBinningPsKillDisable = 0x0, // Enable Binning.
    DisableBinningPsKillEnable = 0x1, // Disable Binning
    DisableBinningPsKillDefault = 0x2, // Default PAL values
};

enum BinningOverridePbbForMrt :  uint32_t 
{
    BinningOverridePbbForMrtDisable = 0x0, // Force PBB off for shader
    BinningOverridePbbForMrtEnable = 0x1, // Force PBB on for shader
    BinningOverridePbbForMrtDefault = 0x2, // Default PAL value
};

enum DxgiEnable :  uint32_t 
{
    DxgiDisabled = 0x0, // Disable DXGI present
    DxgiHdrStereoOnly = 0x1, // Enable DXGI present when the OS HDR mode is enabled or if Stereo is active
    DxgiEnabled = 0x2, // Always use DXGI present
};

enum DxgiPresentSettings :  uint32_t 
{
    DxgiDefault = 0x0, // Use default DXGI settings in PAL.
    DxgiUseIntermediateCopy = 0x1, // Use an intermdiate image as the backbuffer and copy it into the DXGI backbuffer on present. Use in the event any issues arise.
    DxgiUseSwapEffectDiscard = 0x2, // Enable Flip Effect Discard (Swapchain contents are not preserved after presentation), enabling this will allow the OS to optimize composition. Only use when you know swapchain contents will not be read after presentation.
    DxgiDisableWaitableSwapchain = 0x4, // Disables waitable swapchain behavior, this will make the swapchain block in Present() instead of AcquireImage(), it will also reset the frame latency to the DXGI default of 3
    DxgiUseSafeSynchronization = 0x8, // Force a minimum of 3 images with a frame latency of imageCount-1 for DXGI swapchains. Note that forcing different image counts may be problematic for some older apps
    DxgiHdrFormatCompatability = 0x10, // Report unsupported HDR formats for backwards compatability and override then at creation, affects ImageView creation also
    DxgiEnablePresentThread = 0x20, // Enable presenting from a different thread, can improve performance in CPU bound cases
    DxgiDelayAcquireToPostPresent = 0x40, // When acquiring more than one image, delay the acquire until after present. This may help cover some corner cases with respect to DWM presentation
    DxgiAdaptiveSync = 0x80, // Allow PAL to use a lower overhead synchronization method when the expected present mode is fullsreen. This can improve performance but may cause momentary corruption when the present mode is transitioned to windowed
};

enum ShaderReplaceMode :  uint32_t 
{
    ShaderReplaceDisable = 0x0, // Disable shader replacement (default)
    ShaderReplaceShaderHash = 0x1, // Enable shader hash based shader replacement, for any shader whose hash is AAA, if there is a file named shader_0xAAA_replace.spv under ShaderReplacementDir, this file will be used to replace the original shader.
    ShaderReplaceShaderPipelineHash = 0x2, // Enable shader hash plus pipeline hash filter based shader replacement, shader hash based shader replacement will only be enabled for pipelines whose hash is in ShaderReplacementPipelineHashs.
    ShaderReplacePipelineBinaryHash = 0x3, // Enable pipeline binary hash based pipeline binary replacement, for any pipeline binary whose hash is AAA, if there is a file named PipelneXXX_0xAAA_replace.elf under ShaderReplacementDir, this file will be used to replace the original pipeline binary.
    ShaderReplaceShaderISA = 0x4, // Enable replace ISA shader in the pipeline, For every pipeline in the ShaderReplacementPipelineHashs, would find if there is a file named 0xAAA_replace.txt under ShaderReplacementDir, would be loaded for the replacement the replace shader look like this  *----offset: ISACODE----* 848:0x7E120303   1480:0x7E1E0303  2592:0x7E0E030E
    ShaderReplaceShaderHashPipelineBinaryHash = 0x5, // Enable both shader hash based shader replacement and pipeline binary hash based pipeline binary replacement. In cases where both a pipeline and one or more of its shaders are replaced, the replacement shader will take precedence and will potentially change the hash of the pipeline. The pipeline will only be replaced if the pipeline replacement file has the new hash.
};

enum NggSubgroupSizingType :  uint32_t 
{
    NggSubgroupAuto = 0x0, // Sub-group size is allocated as optimally determined
    NggSubgroupMaximumSize = 0x1, // Sub-group size is allocated to the maximum allowable size by the hardware
    NggSubgroupHalfSize = 0x2, // Sub-group size is allocated as to allow half of the maximum allowable size by the hardware
    NggSubgroupOptimizeForVerts = 0x3, // Sub-group size is optimized for vertex thread utilization
    NggSubgroupOptimizeForPrims = 0x4, // Sub-group size is optimized for primitive thread utilization
    NggSubgroupExplicit = 0x5, // Sub-group size is allocated based on explicitly-specified vertsPerSubgroup and primsPerSubgroup
};

enum DisableNggCullingFlags :  uint32_t 
{
    DisableNggCullingNever = 0x0, // Leave NGG culling unchanged (default)
    DisableNggCullingSingleColorAttachment = 0x1, 
    DisableNggCullingMultipleColorAttachments = 0x2, 
    DisableNggCullingDepthOnly = 0x4, 
    DisableNggCullingAlways = 0x8, 
};

enum OptimizeTessFactorMode :  uint32_t 
{
    OptimizeTessFactorAuto = 0x0, // Determine the tessellation fator optimization by compiler.
    OptimizeTessFactorDisable = 0x1, // Force disable tessellation factor optimization.
    OptimizeTessFactorEnable = 0x2, // Force enable tessellation fator optimziation.
};

enum RelaxedPrecisionFlags :  uint32_t 
{
    RelaxedPrecisionNone = 0x0, // Disable relaxed precision handling.
    RelaxedPrecisionEnabled = 0x1, // Enable generic relaxed precision handling (required for other settings).
    RelaxedPrecisionRelaxDefaultUniform = 0x2, // Force default uniform to 16-bit type if decorated with relaxed precision.
    RelaxedPrecisionKeepAllOutput = 0x4, // Align all fragment shader input to pre-stage output precision when in-out precision does not match.
    RelaxedPrecisionIgnoreSrcOperand = 0x8, // Ignore the relaxed precision limitation of source operands, this will relax the rule of determining whether the conversion can be performed.
    RelaxedPrecisionRelaxSpecialUniformBlock = 0x10, // Enable relaxed precision on special uniform block.
};

enum ShaderCacheMode :  uint32_t 
{
    ShaderCacheDisable = 0x0, // Shader Cache is disabled.
    ShaderCacheEnableRuntimeOnly = 0x1, // Shader Cache is enabled for runtime use only.
    ShaderCacheEnableOnDisk = 0x2, // Shader Cache is enabled with on-disk file backing.
    ShaderCacheForceInternalCacheOnDisk = 0x3, // Shader Cache is forced on with on-disk file backing even for applications that specify pipeline caches.
};

enum PipelineCacheCompression :  uint32_t 
{
    PipelineCacheCompressDisabled = 0x0, // No compression
    PipelineCacheCompressInMemory = 0x1, // In-memory and on-disk compression
    PipelineCacheCompressOnDisk = 0x2, // On-disk compression only
};

enum PipelineDumpFilters :  uint32_t 
{
    PipelineDumpFilterNone = 0x0, // Do not disable any pipeline type
    PipelineDumpFilterCs = 0x1, // Disable pipeline dump for Cs pipelines
    PipelineDumpFilterNgg = 0x2, // Disable pipeline dump for NGG pipelines
    PipelineDumpFilterGs = 0x4, // Disable pipeline dump for Gs pipelines 
    PipelineDumpFilterTess = 0x8, // Disable pipeline dump for Tess pipelines
    PipelineDumpFilterVsPs = 0x10, // Disable pipeline dump for VsPs pipelines
};

enum LlpcRaytracingMode :  uint32_t 
{
    RaytracingNone = 0x0, // No Raytracing compiling path.
    RaytracingLegacy = 0x1, // Legacy Raytracing.
    RaytracingContinufy = 0x2, // Raytracing Continufy path
    RaytracingContinuations = 0x3, // Raytracing Continuations
};

enum CpsFlag :  uint32_t 
{
    CpsNoFlag = 0x0, // No extra flag
    CpsFlagStackInGlobalMem = 0x1, // Put stack in global memory instead of scratch, for ray sorting.
};

enum TraceRayCounterMode :  uint32_t 
{
    TraceRayCounterDisable = 0x0, // Disable trace ray counters
    TraceRayCounterRayHistoryLight = 0x1, // Enable ray history light logging (only logs TraceRay parameters)
    TraceRayCounterRayHistoryFull = 0x2, // Enable full ray history logging (logs BVH tokens per iteration)
    TraceRayCounterTraversal = 0x3, // Enable per-ray traversal counter logging.
    TraceRayCounterCustom = 0x4, // Enable custom logging to counter buffer.
    TraceRayCounterDispatch = 0x5, // Enable dispatch traversal counters.
};

enum TraceRayProfileFlags :  uint32_t 
{
    TraceRayProfileDisable = 0x0, 
    TraceRayProfileForceOpaque = 0x1, 
    TraceRayProfileAcceptFirstHitAndEndSearch = 0x2, 
    TraceRayProfileSkipClosestHitShader = 0x4, 
    TraceRayProfileCullFrontFacingTriangles = 0x8, 
    TraceRayProfileCullBackFacingTriangles = 0x10, 
    TraceRayProfileForceMaxIteration = 0x20, 
};

enum BoxSortingMode :  uint32_t 
{
    BoxSortingClosest = 0x0, // Traversal is ordered to enter the children that intersect the ray closer to the ray origin first.
    BoxSortingLargest = 0x1, // Traversal is ordered to enter the children that have the largest interval where the box intersects the ray first.
    BoxSortingMidPoint = 0x2, // Traversal is ordered to enter the children that have a midpoint in the interval where the box intersects that has the lowest intersection time before clamping.
    BoxSortingDisabled = 0x3, // Disable box sorting heuristic.
    BoxSortingLargestFirstAndClosest = 0x4, // Auto select box sort mode. If rayFlag indicates RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, choose BoxSortLargest. Otherwise choose BoxSortClosest.
    BoxSortingLargestFirstAndClosestMidpoint = 0x5, // Auto select box sort mode. If rayFlag indicates RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, choose BoxSortLargest. Otherwise choose BoxSortMidPoint.
    BoxSortingDisabledOnAcceptFirstHit = 0x6, // When BvhBuilder Node sort is enabled, turn off boxSort if rayflag allow acceptting first hit.
};

enum Fp16BoxNodesInBlasMode :  uint32_t 
{
    Fp16BoxNodesInBlasModeNone = 0x0, // No interior box nodes are fp16 (so all nodes are fp32)
    Fp16BoxNodesInBlasModeLeaves = 0x1, // Only leaf nodes (parents of triangles) are fp16
    Fp16BoxNodesInBlasModeMixed = 0x2, // Dynamic mix of fp16 and fp32 nodes. Sets fp32 box to fp16 if conversion results in surface area grows < a threshold. Threshold set by fp16BoxNodesInBlasModeMixedThreshold
    Fp16BoxNodesInBlasModeAll = 0x3, // All interior box nodes are fp16
};

enum RebraidType :  uint32_t 
{
    RebraidTypeOff = 0x0, // No Rebraid
    RebraidTypeV1 = 0x1, // Version 1 Rebraid
    RebraidTypeV2 = 0x2, // Version 2 Rebraid
};

enum TriangleCompressionAutoMode :  uint32_t 
{
    TriangleCompressionAutoModeDefaultBuild = 0x0, // Compression is enabled for all default and FastTrace builds.
    TriangleCompressionAutoModeFastTrace = 0x1, // Compression is enabled for all FastTrace builds.
    TriangleCompressionAutoModeCompaction = 0x2, // Compression is enabled for all builds with the AllowCompaction flag.
    TriangleCompressionAutoModeDefaultBuildWithCompaction = 0x3, // Compression is enabled for default and FastTrace builds with the AllowCompaction flag.
    TriangleCompressionAutoModeFastTraceWithCompaction = 0x4, // Compression is enabled for FastTrace builds with the AllowCompaction flag.
    TriangleCompressionAutoModeDefaultBuildOrCompaction = 0x5, // Compression is enabled for default and FastTrace builds and all builds with the AllowCompaction flag.
    TriangleCompressionAutoModeFastTraceOrCompaction = 0x6, // Compression is enabled for FastTrace builds and all builds with the AllowCompaction flag.
    TriangleCompressionAutoModeDisabled = 0x7, // Compression disabled flag.
    TriangleCompressionAutoModeAlwaysEnabled = 0x8, // Compression always enabled flag.
};

enum RtCompileMode :  uint32_t 
{
    RtCompileModeAuto = 0x0, 
    RtCompileModePreferUnified = 0x1, 
    RtCompileModeIndirect = 0x2, 
};

enum TriangleCompressionMode :  uint32_t 
{
    NoTriangleCompression = 0x0, // NoTriangleCompression is defined as storing a single triangle along with the triangle sideband data (geometryIndex, primitiveIndex, geometryFlags) inside the triangle node.
    PairTriangleCompression = 0x2, // PairTriangleCompression is similar to TwoTriangleCompression, except that the triangles in the node share a bounding box in the parent box node.
    AutoTriangleCompression = 0x3, // Auto-select triangleCompressionMode is defined as to allow enabling Triangle Compression based on BVH build flags. If the BVH build flags set to AllowCompaction | PreferFastTrace, Currently will auto select TwoTriangleCompression. Otherwise auto select NoTriangleCompression.
};

enum BvhBuildModeOverride :  uint32_t 
{
    BvhBuildModeOverrideDisabled = 0x0, // Do not override build mode
    BvhBuildModeOverrideLinear = 0x1, // Force all builds to use linear BVH builder
    BvhBuildModeOverridePLOC = 0x3, // Force all builds to use parallel locally-ordered clustering BVH builder
};

enum ShaderInlineFlags :  uint32_t 
{
    InlineNone = 0x0, // Inlining disabled
    InlineMissShader = 0x1, // Inline miss shaders
    InlineClosestHitShader = 0x2, // Inline closesthit shaders
    InlineAnyHitShader = 0x4, // Inline anyhit shaders
    InlineIntersectionShader = 0x8, // Inline intersection shaders
    InlineCallableShader = 0x10, // Inline callable shaders
    InlineTraceRays = 0x20, // Inline TraceRays shader
    InlineAll = 0x3F, // Inline ALL shaders
};

enum BvhCpuBuildMode :  uint32_t 
{
    BvhCpuBuildModeRecursiveSAH = 0x0, // Use recursive SAH builder
    BvhCpuBuildModeRecursiveLargestExtent = 0x1, // Use recursive largest extent builder
};

enum IndirectConvention :  uint32_t 
{
    IndirectConvention0 = 0x0, // Ignore indirect calling convention
    IndirectConvention1 = 0x1, // Enable indirect calling convention
};

enum EmulatedRtIpLevel :  uint32_t 
{
    EmulatedRtIpLevelNone = 0x0, // Use default hardware supported ray tracing IP level.
    HardwareRtIpLevel1_1 = 0x1, // Force ray tracing IP level 1.1 feature set using hardware intrinsic.
    EmulatedRtIpLevel1_1 = 0x2, // Emulate ray tracing IP level 1.1 feature set.
    EmulatedRtIpLevel2_0 = 0x3, // Emulate ray tracing IP level 2.0 feature set.
};

enum BatchBvhModes :  uint32_t 
{
    BatchBvhModeDisabled = 0x0, // Disables BVH batching
    BatchBvhModeExplicit = 0x1, // Relies on batching done by application.
    BatchBvhModeImplicit = 0x2, // Enables our BvhBatchLayer for implicit BVH batching. Adds some overhead, but could be beneficial for apps written sub-optimally.
    BatchBvhModeImplicitAndLog = 0x3, // Same as BatchBvhModeImplicit, but also logs layer activity to [AMD_DEBUG_DIR]/BvhBatchLog.txt. AMD_DEBUG_DIR must be set when this option is enabled (otherwise initialization will fail).
};

enum DbgBarrierCmd :  uint64_t 
{
    DbgBarrierDrawNonIndexed = 0x1, // Any non-indexed draw (including indirect)
    DbgBarrierDrawIndexed = 0x2, // Any indexed draw (including indirect)
    DbgBarrierDrawIndirect = 0x4, // Any indirect draw
    DbgBarrierDispatch = 0x8, // Any direct dispatch
    DbgBarrierDispatchIndirect = 0x10, // Any indirect dispatch
    DbgBarrierCopyBuffer = 0x20, // Any transfer copy involving a buffer
    DbgBarrierCopyImage = 0x40, // Any transfer copy involving an image
    DbgBarrierCopyQueryPool = 0x80, // Any transfer copy involving a query pool
    DbgBarrierClearColor = 0x100, // Any color clear operation (including render pass clears)
    DbgBarrierClearDepth = 0x200, // Any depth-stencil clear operation (including render pass clears)
    DbgBarrierResolve = 0x400, // Any resolve operation (including render pass resolves)
    DbgBarrierBeginRenderPass = 0x800, // vkCmdBeginRenderPass
    DbgBarrierNextSubpass = 0x1000, // vkCmdNextSubpass
    DbgBarrierEndRenderPass = 0x2000, // vkCmdEndRenderPass
    DbgBarrierSetResetEvent = 0x4000, // vkCmdSetEvent or vkCmdResetEvent
    DbgBarrierPipelineBarrierWaitEvents = 0x8000, // vkCmdPipelineBarrier or vkCmdWaitEvents
    DbgBarrierQueryBeginEnd = 0x10000, // vkCmdBeginQuery or vkCmdEndQuery
    DbgBarrierQueryReset = 0x20000, // vkCmdResetQueryPool
    DbgBarrierExecuteCommands = 0x40000, // vkCmdExecuteCommands
    DbgBarrierCmdBufStart = 0x80000, // Start of the command buffer
    DbgBarrierCmdBufEnd = 0x100000, // End of the command buffer
    DbgBarrierBindPipeline = 0x200000, // vkCmdBindPipeline
    DbgBarrierBindSetsPushConstants = 0x400000, // vkCmdBindDescriptorSets or vkCmdPushConstants
    DbgBarrierBindIndexVertexBuffer = 0x800000, // vkCmdBindIndexBuffer or vkCmdBindVertexBuffers
    DbgBarrierWriteTimestamp = 0x1000000, // vkCmdWriteTimestamp
    DbgBarrierSetDynamicPipelineState = 0x2000000, // Any vkCmdSet* which programs dynamic pipeline state
    DbgBarrierVideo = 0x4000000, // Any video operations
#if VKI_RAY_TRACING
    DbgBuildAccelerationStructureTLAS = 0x8000000, // Build ray tracing operations
#endif
#if VKI_RAY_TRACING
    DbgBuildAccelerationStructureBLAS = 0x10000000, // Build ray tracing operations
#endif
#if VKI_RAY_TRACING
    DbgTraceRays = 0x20000000, // Trace ray tracing operations
#endif
    DbgBarrierDrawMeshTasks = 0x40000000, // Any draw mesh tasks
    DbgBarrierDrawMeshTasksIndirect = 0x80000000, // Any indirect draw mesh tasks
    DbgBarrierBeginRendering = 0x100000000, // Begin rendering
    DbgBarrierPushDescriptorSet = 0x200000000, // vkCmdPushDescriptorSetKHR or vkCmdPushDescriptorSetWithTemplateKHR
    DbgBarrierOther = 0x400000000, // Any other command not listed above
};

enum ResourceBarrierOptions :  uint32_t 
{
    DefaultResourceBarrier = 0x0, // Default barrier queues
    KeepShaderCoher = 0x100, // Keep shader domain always coherent on GFX10+ thus avoiding L2 cache flushes/invalidations in shader-to-shader barrier cases at the expense of always flushing/invalidating L1 caches. This does NOT violate the Vulkan separate access mask rule. This behavior may not be beneficial on GFX10+.
    AvoidCpuMemoryCoher = 0x200, // Avoid CPU and memory domain coherency on GFX10+ unless corresponding flags are explicitly requested to lower the number of L2 cache flushes/invalidations. This does NOT violate the Vulkan separate access mask rule. This behavior is preferred on GFX10+ as all other accesses go through the L2.
    PreferFlushOverInv = 0x400, // By default we invalidate input caches to accomodate the Vulkan separate access mask rule. When this is set we'll instead flush all output caches instead to achieve the same goal. Mutually exclusive with SkipDstCacheInv. May or may not be beneficial for certain applications.
    CombinedAccessMasks = 0x800, // Ignore Vulkan separate access mask rule
    SkipDstCacheInv = 0x1000, // Do not invalidate dest caches if src cache was not updated. This should be enabled by default for Legacy barriers only.
};

enum BarrierFilterOptions :  uint32_t 
{
    BarrierFilterDisabled = 0x0, // Do nothing (default)
    SkipStrayExecutionDependencies = 0x1, // The driver is unable to know if a source pipeline stage mask is for a standalone execution dependency or the access scope of a skippable memory dependency. Checking for the source and destination pipeline stage masks doesn't always provide the developer's intent either.
    SkipImageLayoutUndefined = 0x2, // Ignore image memory barrier transitions out of undefined in the hope that there will be a full coverage clear to the image next making this likely mask RAM initialization redundant. Transitions to transfer dst optimal are not skipped to avoid issues with slow clears and copies, which require initialized metadata.
    SkipDuplicateResourceBarriers = 0x4, // Ignores resource barriers that have the same source and destination parameters in case a full cross-bar sync isn't required.
    FlushOnHostMask = 0x40, // The driver cannot know the intention behind a host stage mask in a pipeline barrier, flush GPU work to avoid any dependency issues.
};

enum ForceImageSharingMode :  uint32_t 
{
    ForceImageSharingModeDefault = 0x0, // Don't force anything
    ForceImageSharingModeExclusive = 0x1, // Exclusive queue family access reduces some memory dependency operations and removes the restriction that the image layout must be supported for multiple queue families. VK_SHARING_MODE_CONCURRENT is only acceptable to ignore when the application unnecessarily specified extra queue families without accessing the resource using them. Setting this option illegally might avoid all the pitfalls in a given application, but they are too numerous to list (e.g. requiring a decompress on an async compute queue).
    ForceImageSharingModeExclusiveForNonColorAttachments = 0x2, // Force exclusive image sharing mode for all images except those marked as color attachments. Exclusive queue family access reduces some memory dependency operations and removes the restriction that the image layout must be supported for multiple queue families.
};

enum DeprecateWave64 :  uint32_t 
{
    DeprecateWave64Disabled = 0x0, // Default case. Wave64 is both reported and enabled.
    DeprecateWave64Cs = 0x1, // Wave64 can be reported but wave32 will be forced for compute shaders internally. If app uses subgroup operations then this setting still might not force desired wavesize since subgroupsize will take precedence. To avoid that DeprecateWave64Reporting MUST be set along with this setting.
    DeprecateWave64NonCs = 0x2, // Wave64 can be reported but wave32 will be forced for all non-compute shaders. If app uses subgroup operations then this setting still might not force desired wavesize since subgroupsize will take precedence. To avoid that DeprecateWave64Reporting MUST be set along with this setting.
    DeprecateWave64Reporting = 0x4, // Only wave32 is reported.
    DeprecateWave64WaveIntrinsics = 0x8, // This flag must be set together with DeprecateWave64Reporting. When set, shader specified subgroupSize will be overriden to wave32.
    DeprecateWave64All = 0xFFFFFFFF, // Wave32 is reported and forced for all shaders.
};

enum RebraidQualityHeuristicType :  uint32_t 
{
    RebraidQualityHeuristicInstanceEmptyArea = 0x0, // Uses SA of empty space due to opening
    RebraidQualityHeuristicInstanceSurfaceArea = 0x1, // Uses SA of Instance
};

enum ForceRebuildForUpdatesModes :  uint32_t 
{
    ForceRebuildForUpdatesNone = 0x0, // Disable build flag overrides
    ForceRebuildForUpdatesTopLevel = 0x1, // Override flags for top level acceleration structures only
    ForceRebuildForUpdatesBottomLevel = 0x2, // Override flags for bottom level acceleration structures only
    ForceRebuildForUpdatesAll = 0x3, // Override flags for all acceleration structures only
};

enum AppProfileDumpFlags :  uint32_t 
{
    None = 0x0, // Default, do not dump app profile information
    AppProfileValue = 0x1, // Dump the application path and the applied app profile index (like ForceAppProfileValue)
};

enum PwsMode :  uint32_t 
{
    Disabled = 0x0, 
    Enabled = 0x1, 
    NoLateAcquirePoint = 0x2, 
};

enum MallNoAllocResourcePolicy :  uint32_t 
{
    MallNoAllocDefault = 0x0, // Default policy for resources
    MallNoAllocCt = 0x1, // NOALLOC policy for color target resource
    MallNoAllocDs = 0x2, // NOALLOC policy for depth stencil resource
    MallNoAllocImageViewSrds = 0x4, // NOALLOC policy for image view shader resource descriptors
    MallNoAllocBufferViewSrds = 0x8, // NOALLOC policy for buffer view shader resource descriptors
    MallNoAllocBvh = 0x10, // NOALLOC policy for BVH (bounding volume hierarchy, used by ray-trace)
};

enum MallNoAllocCtPolicy :  uint32_t 
{
    MallNoAllocCtDefault = 0x0, // Default policy for color target resources
    MallNoAllocCtAsSnsr = 0x1, // NOALLOC policy when color target resource is used as shader non-storage resource (SNSR <-> SRV)
    MallNoAllocCtAsCt = 0x2, // NOALLOC policy when color target resource is used as color target
    MallNoAllocCtAlways = 0x4, // NOALLOC always independent of use
};

enum MallNoAllocSsrPolicy :  uint32_t 
{
    MallNoAllocSsrDefault = 0x0, // Default policy for shader storage resources
    MallNoAllocSsrAsSnsr = 0x1, // NOALLOC policy when shader storage resource is used as shader non-storage resource (SNSR <-> SRV)
    MallNoAllocSsrAsSsr = 0x2, // NOALLOC policy when shader storage resource is used as shader storage resource
    MallNoAllocSsrAlways = 0x4, // NOALLOC always independent of use
};

enum MallNoAllocDsPolicy :  uint32_t 
{
    MallNoAllocDsDefault = 0x0, // Default policy for depth stencil resources
    MallNoAllocDsAsSnsr = 0x1, // NOALLOC policy when depth stencil resource is used as shader non-storage resource (SNSR <-> SRV)
    MallNoAllocDsAsDs = 0x2, // NOALLOC policy whendepth stencil resource is used as depth stencil resource
    MallNoAllocDsAlways = 0x4, // NOALLOC always independent of use
};

enum MallNoAllocCtSsrPolicy :  uint32_t 
{
    MallNoAllocCtSsrDefault = 0x0, // Default policy for color target and shader storage resources
    MallNoAllocCtSsrAsSnsr = 0x1, // NOALLOC policy when color target and shader storage resource is used as shader non-storage resource (SNSR <-> SRV)
    MallNoAllocCtSsrAsDs = 0x2, // NOALLOC policy when color target and shader storage resource is used as depth stencil resource
    MallNoAllocCtSsrAlways = 0x4, // NOALLOC always independent of use
};

enum OverrideChoiceForHeapFlags :  uint32_t 
{
    OverrideChoiceForGartUswc = 0x1, // Force another heap in place of GART USWC allocations
    OverrideChoiceForGartCacheable = 0x2, // Force another heap in place of GART cacheable allocations
};

enum PreciseAnisoMode :  uint32_t 
{
    EnablePreciseAniso = 0x0, // PrecisAniso will be enabled. Highest image quality.
    DisablePreciseAnisoAfOnly = 0x1, // PrecisAniso will be disabled only for anisotropic samplers.
    DisablePreciseAnisoAll = 0x2, // PrecisAniso will be disabled for all samplers. Lowest image quality.
};

enum BGFSEnableFlags :  uint32_t 
{
    BGFSEnableWddm1Immediate = 0x1, // Win7-8 + VK_PRESENT_MODE_IMMEDIATE_KHR 
    BGFSEnableWddm1Mailbox = 0x2, // Win7-8 + VK_PRESENT_MODE_MAILBOX_KHR 
    BGFSEnableWddm1Fifo = 0x4, // Win7-8 + VK_PRESENT_MODE_FIFO_KHR 
    BGFSEnableWddm1FifoRelaxed = 0x8, // Win7-8 + VK_PRESENT_MODE_FIFO_RELAXED_KHR
    BGFSEnableWddm2Immediate = 0x10, // Win10  + VK_PRESENT_MODE_IMMEDIATE_KHR
    BGFSEnableWddm2Mailbox = 0x20, // Win10  + VK_PRESENT_MODE_MAILBOX_KHR
    BGFSEnableWddm2Fifo = 0x40, // Win10  + VK_PRESENT_MODE_FIFO_KHR
    BGFSEnableWddm2FifoRelaxed = 0x80, // Win10  + VK_PRESENT_MODE_FIFO_RELAXED_KHR
    BGFSEnableWddm1MultiGpu = 0x100, // Win7-8 + Multi-GPU
    BGFSEnableWddm2MultiGpu = 0x200, // Win10  + Multi GPU
};

enum StrictImageSizeRequirements :  uint32_t 
{
    StrictImageSizeOff = 0x0, // Disable strictImageSizeRequirements always
    StrictImageSizeOn = 0x1, // Enable strictImageSizeRequirements always
    StrictImageSizeAppControlled = 0x2, // App enables strictImageSizeRequirements when KHR_maintenance4 is enabled
};

enum OptimizeCmdbufMode :  uint32_t 
{
    EnableOptimizeForRenderPassContinue = 0x0, // OptimizeCmdbuf will be enabled only for render pass continue.
    EnableOptimizeCmdbuf = 0x1, // OptimizeCmdbuf will be always enabled.
    DisableOptimizeCmdbuf = 0x2, // OptimizeCmdbuf will be disabled.
};

enum ForceEnableDcc :  uint32_t 
{
    ForceDccDefault = 0x0, // Let PAL heuristics decide what's best. Don't force anything in xgl.
    ForceDccFor2DShaderStorage = 0x1, // Force enable DCC for 2D shader storage resources.
    ForceDccFor3DShaderStorage = 0x2, // Force enable DCC for 3D shader storage resources.
    ForceDccForColorAttachments = 0x4, // Force enable DCC for color attachments which are also shader storage resources.
    ForceDccForNonColorAttachmentShaderStorage = 0x8, // Force enable DCC for shader storage resources that are not color attachments.
    ForceDccFor32BppShaderStorage = 0x10, // Force enable DCC for shader storage resources with BPP range from 32 to 64.
    ForceDccFor64BppShaderStorage = 0x20, // Force enable DCC for shader storage resources with 64 BPP or deeper.
    ForceDisableDcc = 0x40, // Force disable DCC for every resource irrespective of PAL heuristics.
    ForceDisableDccForSharedImages = 0x80, // Force disable DCC for externally sharable resources.
};

enum ForceLowPrecisionDepthImage :  uint32_t 
{
    ForceLowPrecisionDepthImageDefault = 0x0, // Don't force anything in XGL.
    ForceLowPrecisionDepthImageForNonDepthAttachments = 0x1, // Force convert D32/D24 to D16 for depth attachments.
    ForceLowPrecisionDepthImageForDepthAttachments = 0x2, // Force convert D32/D24 to D16 for non depth attachments.
};

enum DisplayableDcc :  uint32_t 
{
    DisplayableDccEnabled = 0x0, // Enable DisplayableDcc
    DisplayableDccDisabledForMgpu = 0x1, //  Disable DisplayableDcc for MGPU configurations
    DisplayableDccDisabled = 0x2, // Disable DisplayableDcc for all configurations
};

enum ThreadGroupSizeX :  uint32_t 
{
    NotOverrideThreadGroupSizeX = 0x0, // Not override the threadgroupsizeX
    ThreadGroupSizeX_8 = 0x8, // Override the threadgroupsizeX to 8 in wave32 or wave64
    ThreadGroupSizeX_16 = 0x10, // Override the threadgroupsizeX to 16 in wave64
};

enum ThreadGroupSizeY :  uint32_t 
{
    NotOverrideThreadGroupSizeY = 0x0, // Not override the threadgroupsizeY
    ThreadGroupSizeY_8 = 0x8, // Override the threadgroupsizeY to 8 in wave32 or wave64
    ThreadGroupSizeY_16 = 0x10, // Override the threadgroupsizeY to 16 in wave64
};

enum ThreadGroupSizeZ :  uint32_t 
{
    NotOverrideThreadGroupSizeZ = 0x0, // Not override the threadgroupsizeZ
    ThreadGroupSizeZ_1 = 0x1, // Override the threadgroupsizeZ to 1 in wave32 or wave64
};

enum DevModeSqttMarkerEnableFlags :  uint32_t 
{
    DevModeSqttMarkerEnableCbStart = 0x1, // Enable command buffer start instrumentation marker
    DevModeSqttMarkerEnableCbEnd = 0x2, // Enable command buffer end instrumentation marker
    DevModeSqttMarkerEnableEvent = 0x4, // Enable per-draw/dispatch event instrumentation markers
    DevModeSqttMarkerEnableBarrier = 0x8, // Enable barrier instrumentation markers
    DevModeSqttMarkerEnableGeneralApi = 0x10, // Enable general API (per entry point call) instrunmentation markers
    DevModeSqttMarkerEnableUserEvent = 0x20, // Enable user event (app string) markers
    DevModeSqttMarkerEnableEventWithDims = 0x40, // Enable dispatch events with thread dimensions
    DevModeSqttMarkerEnableBoundShaderHashes = 0x80, // Write bound shader hashes as user event markers
    DevModeSqttMarkerEnablePipelineBind = 0x100, // Enable pipeline bind markers
    DevModeSqttMarkerEnablePresent = 0x200, // Enable present markers
};

enum ShaderMode :  uint32_t 
{
    TaskShader = 0x0, // Task Shader
    VertexShader = 0x1, // Vertex Shader
    TessellationControlShader = 0x2, // Tessellation Control Shader
    TessellationEvaluationShader = 0x3, // Tessellation Evaluation Shader
    GeometryShader = 0x4, // Geometry Shader
    MeshShader = 0x5, // Mesh Shader
    FragmentShader = 0x6, // Fragment Shader
    ComputeShader = 0x7, // Compute Shader
};

enum ShaderWaveSize :  uint32_t 
{
    WaveSizeAuto = 0x0, // Let the driver pick the best wave size for this shader
    WaveSize64 = 0x2, // Force wave size to 64 threads
    WaveSize32 = 0x3, // Force wave size to 32 threads
};

enum WgpMode :  uint32_t 
{
    WgpModeAuto = 0x0, // Let the driver pick the best WgpMode for this shader
    WgpModeCu = 0x1, // All 4 SIMDs in a workgroup processor are considered when waves are allocated for execution
    WgpModeWgp = 0x2, // Only the 2 SIMDs in a CU are considered when waves are allocated for execution
};

enum DccMode :  uint32_t 
{
    DccDefaultMode = 0x0, // Default
    DccDisableMode = 0x1, // Disabled
    DccEnableMode = 0x2, // Enabled
    DccFmaskMode = 0x3, // Disabled
};

enum TextureFilterOptimizationSettings :  uint32_t 
{
    TextureFilterOptimizationsDisabled = 0x0, 
    TextureFilterOptimizationsEnabled = 0x1, 
    TextureFilterOptimizationsAggressive = 0x2, 
};

enum ShaderThreadGroupSizeX :  uint32_t 
{
    NotOverrideShaderThreadGroupSizeX = 0x0, 
    ShaderThreadGroupSizeX_8 = 0x8, 
    ShaderThreadGroupSizeX_16 = 0x10, 
};

enum ShaderThreadGroupSizeY :  uint32_t 
{
    NotOverrideShaderThreadGroupSizeY = 0x0, 
    ShaderThreadGroupSizeY_8 = 0x8, 
    ShaderThreadGroupSizeY_16 = 0x10, 
};

enum ShaderThreadGroupSizeZ :  uint32_t 
{
    NotOverrideShaderThreadGroupSizeZ = 0x0, 
    ShaderThreadGroupSizeZ_1 = 0x1, 
};

enum RtTossPointEnums :  uint32_t 
{
    RtTossPointDisabled = 0x0, // No toss points, raytracing executes normally
    RtTossPointTraversal = 0x1, // Disable traversal
    RtTossPointTlas = 0x2, // Disable traversal, TLAS build/update
    RtTossPointBlasUpdate = 0x3, // Disable traversal, TLAS build/update, BLAS update
    RtTossPointBlasBuild = 0x4, // Disable traversal, TLAS build/update, BLAS update, BLAS build
};

enum GpuRtGpuDebugFlag :  uint32_t 
{
    GpuDebugFlagNone = 0x0, // Debugging disabled.
    GpuDebugFlagHostAssert = 0x1, // Trigger asserts in the host debugger.
    GpuDebugFlagHostPrint = 0x2, // Print asserts and debug messages in the host debugger.
    GpuDebugFlagShaderHalt = 0x4, // Halt shader when an assert is triggered.
};

enum VSyncControl :  uint32_t 
{
    VSyncControlAlwaysOff = 0x0, // Vsync is always off
    VSyncControlOffOrAppSpecify = 0x1, // Vsync is determined by the app's present mode on swapchain creation'
    VSyncControlOnOrAppSpecify = 0x2, // Vsync is determined by the app's present mode on swapchain creation'
    VSyncControlAlwaysOn = 0x3, // Vsync is always on
};

enum RpmViewBypassMall :  uint32_t 
{
    RpmViewBypassMallOff = 0x0, // Disable MALL bypass
    RpmViewBypassMallOnRead = 0x1, // Skip MALL for read access of views created in RPM
    RpmViewBypassMallOnWrite = 0x2, // Skip MALL for write access of views created in RPM
    RpmViewBypassMallOnCbDbWrite = 0x4, // Skipp MALL for CB and DB writes.
};

struct RuntimeSettings
{
    // Enable synchronizing cache by adding dumb transition in the barrier
    bool enableDumbTransitionSync;

    // Forces Render pass global-only barrier to not flush/inv any caches when acquire/release barrier
    // interface is used.
    bool forceDisableGlobalBarrierCacheSync;

    // Allow issuing barriers for any image transitions that have no layout transitions but still have
    // different src and dst cache masks. This prevents some required RP transitions from being skipped.
    bool rpBarrierCheckAccessMasks;

    // Use shared CmdAllocator for all command buffers.
    bool useSharedCmdAllocator;

    // Use backup cmdbuffer for DMA command buffers.
    bool useBackupCmdbuffer;

    // The primary heap for the internal CmdAllocator for command data.
    Pal::GpuHeap cmdAllocatorDataHeap;

    // Size of allocation chunks used by CmdAllocators for command data.
    uint32_t cmdAllocatorDataAllocSize;

    // Size of suballocations used by CmdAllocators for command data.
    uint32_t cmdAllocatorDataSubAllocSize;

    // The primary heap for the internal CmdAllocator for embedded data.
    Pal::GpuHeap cmdAllocatorEmbeddedHeap;

    // Size of allocation chunks used by CmdAllocators for embedded data
    uint32_t cmdAllocatorEmbeddedAllocSize;

    // Size of suballocations used by CmdAllocators for embedded data
    uint32_t cmdAllocatorEmbeddedSubAllocSize;

    // Size of allocation chunks used by CmdAllocators for large embedded data
    uint32_t cmdAllocatorLargeEmbeddedAllocSize;

    // Size of suballocations used by CmdAllocators for large embedded data
    uint32_t cmdAllocatorLargeEmbeddedSubAllocSize;

    // The primary heap for the internal CmdAllocator for GPU scratch memory. Note: this field is ignored
    // by PAL and will always be GpuHeapInvisible.
    Pal::GpuHeap cmdAllocatorScratchHeap;

    // Size of allocation chunks used by CmdAllocators for GPU scratch memory.
    uint32_t cmdAllocatorScratchAllocSize;

    // Size of suballocations used by CmdAllocators for GPU scratch memory.
    uint32_t cmdAllocatorScratchSubAllocSize;

    // Prefetch command buffers to L2 using CPDMA
    bool prefetchCommands;

    // Pad vertex buffers if the range isn't the multiple of stride.
    bool padVertexBuffers;

    // Disable resources releasing when resetting command buffer.
    bool disableResetReleaseResources;

    // Enable/Disable command allocator thread safe PAL implementation
    bool threadSafeAllocator;

    // Defines the namespace the pipeline cache UUID belongs to.
    CacheUuidNamespace cacheUuidNamespace;

    // Controls whether the pipeline cache is tagged with the build timestamp.
    bool markPipelineCacheWithBuildTimestamp;

    // Controls which category messages are output to log file (/var/tmp/palLog.txt). e.g. enable
    // PipelineCompileTime(enum LogTagId in icd/api/include/log.h), logTagIdMask |= 1<<PipelineCompileTime
    uint64_t logTagIdMask;

    // Controls how pipeline compile 'fast compile mode' (disable optimizations) is enabled
    PipelineFastCompileMode pipelineFastCompileMode;

    // Controls link optimization flag in pipeline creatation
    PipelineLinkOptimizationMode pipelineLinkOptimizationMode;

    // Control the pipeline descriptor layout for early compile
    PipelineLayoutMode pipelineLayoutMode;

    // Decide how to choose the scheme of pipeline layout
    PipelineLayoutSchemeSelectionStrategy pipelineLayoutSchemeSelectionStrategy;

    // Decide whether to enable push constant compatibility check in fast link
    bool pipelineLayoutPushConstantCompatibilityCheck;

    // Specifies whether to override binning setting for pipeline.
    PipelineBinningMode pipelineBinningMode;

    // Disable binning when the pixels can be rejected before the PS and the PS can kill the pixel.
    DisableBinningPsKill disableBinningPsKill;

    // Max Prims per Batch
    uint32_t binningMaxPrimPerBatch;

    // Binning Context States Per Bin
    uint32_t binningContextStatesPerBin;

    // Binning Persistent State Per Bin
    uint32_t binningPersistentStatesPerBin;

    // Override binning setting for MRT >= 2 targets.
    BinningOverridePbbForMrt binningOverridePbbForMrt;

    // If true, the profile hash (calculated exclusively from SPIRV + entry point) is used as PAL client
    // hash and will appear in e.g. GPUProfiler layer measurements.  Useful when writing and updating
    // pipeline profiles for applications.
    bool pipelineUseProfileHashAsClientHash;

    // If true, the shader hash (calcualte from SPIRV) is used as profile hash.
    bool pipelineUseShaderHashAsProfileHash;

    // Enable dumping of tuning optimizations in JSON format, as applied to shaders for a currently
    // runnning app
    bool enablePipelineProfileDumping;

    // File (in relative path) to dump app shader profile to. Root directory is determined by AMD_DEBUG_DIR
    // environment variable
    char pipelineProfileDumpFile[DD_SETTINGS_MAX_FILE_NAME_SIZE];

    // Relative Path to a JSON file that describes a shader app profile that is parsed at runtime. This
    // setting only triggers on debug builds or builds made with the ICD_RUNTIME_APP_PROFILE=1 option. This
    // file has the same format as the JSON files used to build production shader app profiles. Root
    // directory is determined by AMD_DEBUG_DIR environment variable
    char pipelineProfileRuntimeFile[DD_SETTINGS_MAX_PATH_SIZE];

    // Prints a message to the debugger when a pipeline profile matches a pipeline. Only valid on debug
    // builds or builds built with PAL_ENABLE_PRINTS_ASSERTS=1.
    bool pipelineProfileDbgPrintProfileMatch;

    // If this is true, any production app profile-installed shader optimizations are ignored.
    bool pipelineProfileIgnoresAppProfile;

    // If the driver fails to parse a runtime profile JSON file, it will assert and enter into an infinite
    // loop if this setting is TRUE.
    bool pipelineProfileHaltOnParseFailure;

#if VKI_BUILD_GFX11
    // Enable image MSAA load optimization on Gfx11.
    bool enableImageMsaaLoadOpt;
#endif

    // Disable loop unrolls. This modifies the default pipeline state and can be overwritten by fine-grain
    // override settings.
    bool disableLoopUnrolls;

    // If indexable constant arrays end up as local variables instead of literals, this embeds them  into
    // the shader code so they can be indexed instead of spilling to memory and reading back.
    bool disableEmbedConstArrays;

    // This setting can be used to force depth clamping to be based on Z_EXPORT_ENABLE. It directly affects
    // DISABLE_VIEWPORT_CLAMP bit in h/w register. It should be set only for applications that have perf
    // drops with normal depth clamping beahvior
    bool forceDepthClampBasedOnZExport;

    // This setting can be used to ignore flag VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT in
    // pipeline compile.
    bool ignoreFlagFailOnPipelineCompileRequired;

    // Whether enable dynamicPrimitiveTopologyUnrestricted in driver
    bool dynamicPrimitiveTopologyUnrestricted;

    // Whether use Pal shader library for pipeline library fast-link
    bool useShaderLibraryForPipelineLibraryFastLink;

    // Whether force enable link time optimziation in shader object layer
    bool forceLinkTimeOptimizationInShaderObject;

    // Support FullScreen Frame Metadata.
    bool fullScreenFrameMetadataSupport;

    // For software compositing, perform an SDMA blt on the slave device instead of using its present
    // queue.
    bool useSdmaCompositingBlt;

    // Allows acquiring of swap chain images while present is still active
    bool enableAcquireBeforeSignal;

    // When true, no check is done to see if the swapchain surface size has changed since creation.
    bool ignoreSuboptimalSwapchainSize;

    // A non-zero value will force to set the minimum count of swap chain images
    uint32_t forceMinImageCount;

#if defined(_WIN32)
    // Enable Presentation via DXGI
    DxgiEnable dxgiPresent;
#endif

#if defined(_WIN32)
    // Bitmask of various DXGI presentation settings.
    uint32_t dxgiSettings;
#endif

    // Builds a pipeline by linking reloctable shader elf, which have been built individually.  Only valid
    // when LLPC is the pipeline compiler.
    bool enableRelocatableShaders;

    // Force stride for unaligned vertex buffer format
    bool forcePerComponentFetchForUnalignedVbFormat;

    // Enable uber fetch shder.
    bool enableUberFetchShader;

    // Enable pipeline early compile.
    bool enableEarlyCompile;

    // Whether enable defer compile optimized pipeline, it only affects option EnableUberFetchShader and
    // EnableEarlyCompile
    bool deferCompileOptimizedPipeline;

    // Assistant thread count for deferred compile operation, if count is greater than the internal
    // limitation, the real thread count will be clamped to the limitation.
    uint32_t deferCompileThreadCount;

    // Disable per component fetch in uber fetch shader.
    bool disablePerCompFetch;

    // Disable per instance fetch in uber fetch shader.
    bool disablePerInstanceFetch;

    // Disable instance divisor optimization in uber fetch shader.
    bool disableInstanceDivisorOpt;

    // Force vertex stride is aligned when dynamic vertex stride is enabled
    bool forceAlignedForDynamicStride;

    // Support patch specialized constant
    bool supportPatchSpecConst;

    // Enable pipeline dump, pipeline is stored with .pipe format. You must set AMD_DEBUG_DIR and make sure
    // $AMD_DEBUG_DIR + pipelineDumpDir is  an available directory.
    bool enablePipelineDump;

    // Relative directory where pipeline info is dumped. Root directory is determined by AMD_DEBUG_DIR
    // environment variable. Each unique pipeline is in a separate file within that directory. The log name
    // is based on a hash of the pipeline's create info and  which shader stages are active.
    char pipelineDumpDir[DD_SETTINGS_MAX_PATH_SIZE];

    // Append Executable Name in PipelineDumpDir
    bool appendExeNameToPipelineDump;

    // Enable log mask, enable with 1 in BIL or general output (2) and error message (1) in LLPC.
    uint32_t enableLog;

    // Filename of the log file in LLPC and BIL. Directory of the log file is PipelineDumpDir. Note that
    // logFileName does not includes <path> and <.txt>. Full path of log file is:
    // PipelineDumpDir+LogFileNameBil.txt or PipelineDumpDir+LogFileNameLlpc.txt.
    char logFileName[DD_SETTINGS_MAX_FILE_NAME_SIZE];

    // Enable output diagnostic info. This info may added to AMD IL or external debug log files.
    bool enableDebug;

    // Filename of the file to log debug information.  If the file name is empty, the message will be
    // output to stderr.
    char debugLogFileName[DD_SETTINGS_MAX_FILE_NAME_SIZE];

    // Enable shader replacement.
    ShaderReplaceMode shaderReplaceMode;

    // Relative directory where shader replacement files are stored. Root directory is determined in
    // device.
    char shaderReplaceDir[DD_SETTINGS_MAX_PATH_SIZE];

    // Only valid if shaderReplaceMode is set to 2 and 4. This is a comma separated pipeline hash list.
    // Hash number is in big case, example hash list looks like: 0xAD033E031BF7CB6C,0x1B707F37B7DA34E3
    char shaderReplacePipelineHashes[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Drop specified instruction in pipeline binary for quick debugging shader. It replaces all matching
    // instruction opcodes with NOPs and needs to work with DropPipelineBinaryInstToken and
    // DropPipelineBinaryInstSize together.
    bool enableDropPipelineBinaryInst;

    // Change the API-exposed subgroupSize 0  - The maximum supported waveSize of the GPU (default) 32 -
    // Subgroup size of 32 64 - Subgroup size of 64
    uint32_t subgroupSize;

    // Force task shaders to run with a particular wave size. This is ignored if subgroup operations are
    // used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default) 32 -
    // Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t taskWaveSize;

    // Force vertex shaders to run with a particular wave size. This is ignored if subgroup operations are
    // used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default) 32 -
    // Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t vsWaveSize;

    // Force tessellation control shaders to run with a particular wave size. This is ignored if subgroup
    // operations are used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode
    // (default) 32 - Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t tcsWaveSize;

    // Force tessellation evaluation shaders to run with a particular wave size. This is ignored if
    // subgroup operations are used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs
    // Wave64 mode (default) 32 - Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t tesWaveSize;

    // Force geometry shaders to run with a particular wave size. This is ignored if subgroup operations
    // are used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default)
    // 32 - Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t gsWaveSize;

    // Force mesh shaders to run with a particular wave size. This is ignored if subgroup operations are
    // used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default) 32 -
    // Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t meshWaveSize;

    // Force fragment shaders to run with a particular wave size. This is ignored if subgroup operations
    // are used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default)
    // 32 - Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t fsWaveSize;

    // Force compute shaders to run with a particular wave size. This is ignored if subgroup operations are
    // used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default) 32 -
    // Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t csWaveSize;

#if VKI_RAY_TRACING
    // Force ray tracing shaders to run with a particular wave size. This is ignored if subgroup operations
    // are used by the shader, see SubgroupSize. 0  - Let compiler choose Wave32 vs Wave64 mode (default)
    // 32 - Run in Wave32 mode 64 - Run in Wave64 mode
    uint32_t rtWaveSize;
#endif

    // Enable NGG mode, use an implicit primitive shader on a per-pipeline type basis. Use this instead of
    // PAL setting, NggEnableMode.
    uint32_t enableNgg;

    // [LLPC ONLY] Force NGG to run in culling mode.
    bool nggForceCullingMode;

    // Enable NGG vertex compaction after culling
    bool nggCompactVertex;

    // [LLPC ONLY] Always use primitive shader table to fetch culling-control registers.
    bool nggAlwaysUsePrimShaderTable;

    // Control NGG backface culling algorithm (1 ~ UINT32_MAX, 0 disables it).
    uint32_t nggBackfaceExponent;

    // Define various sizing options of sub-group size for NGG primitive shader.
    NggSubgroupSizingType nggSubgroupSizing;

    // Preferred number of GS primitives to pack into a primitive shader sub-group Use this instead of PAL
    // setting, NggPrimsPerSubgroup.
    uint32_t nggPrimsPerSubgroup;

    // Preferred number of vertices consumed by a primitive shader sub-group Use this instead of PAL
    // setting, NggVertsPerSubgroup.
    uint32_t nggVertsPerSubgroup;

    // Enable culling of primitives that don't meet facing criteria. Use this instead of PAL setting,
    // EnableBackfaceCullMask.
    bool nggEnableBackfaceCulling;

    // Enable discarding of primitives outside of view frustum. Use this instead of PAL setting,
    // EnableAccurateFrustumCullMask.
    bool nggEnableFrustumCulling;

    // Enable simpler frustum culler that is less accurate.
    bool nggEnableBoxFilterCulling;

    // Enable frustum culling based on a sphere.
    bool nggEnableSphereCulling;

    // Enable trivial sub-sample primitive culling. Use this instead of PAL setting,
    // EnableSmallPrimFilterMask.
    bool nggEnableSmallPrimFilter;

    // Enable culling when cull distance exports are present.
    bool nggEnableCullDistanceCulling;

    // Bitmask of cases to selectively disable NGG culling.
    uint32_t disableNggCulling;

    // Force HW to guarantee forward progress per wave on GFX10 0x00000000 - Disable (default) 0x00000001 -
    // Enable for vertex shaders 0x00000002 - Enable for tessellation control shaders 0x00000004 - Enable
    // for tessellation evaluation shaders 0x00000008 - Enable for geometry shaders 0x00000010 - Enable for
    // fragment shaders 0x00000020 - Enable for compute shaders
    uint32_t enableForwardProgress;

    // Allocate waves for execution with 4 SIMDs (WGP) instead of letting the compiler choose  WGP vs CU (2
    // SIMDs) on GFX10
    uint32_t enableWgpMode;

    // Choose a region size, if any, to force the end of the wavefront before the next available quad that
    // falls outside the region. 0x0 - None (default)     - No wave break by region 0x1 - 8x8      - Break
    // outside a 8x8 pixel region 0x2 - 16x16    - Break outside a 16x16 pixel region 0x3 - 32x32    -
    // Break outside a 32x32 pixel region 0xF
    uint32_t waveBreakSize;

    // This option is valid when EnableDropPipelineBinaryInst is set to true. It should be specified with
    // the hex value of first dword of instruction. For example: DropPipelineBinaryInstToken,0xE1084000
    uint32_t dropPipelineBinaryInstToken;

    // This option is valid when EnableDropPipelineBinaryInst is set to true. It should be specified with
    // the size in dword of instruction to be dropped.
    uint32_t dropPipelineBinaryInstSize;

    // [BIL ONLY] Generate optimized IL codes for performance purpose. This may break some precision rules
    // and may not produce 100% conforming IL codes. Therefore, the option should only be enabled via
    // application profile.
    bool enableSpvPerfOptimal;

    // [BIL ONLY] Enable SPIR-V binary validation.
    bool enableSpvValidation;

    // Tessellation factor optimization.
    OptimizeTessFactorMode optimizeTessFactor;

    // [BIL ONLY] Zero initialize AMD IL registers.
    bool zeroInitIlRegs;

    // [BIL ONLY] Skip unsupported SPIR-V instructions.
    bool skipUnsupportedOpCode;

    // A bitmask of flags that control relaxed precision features.
    uint32_t relaxedPrecisionFlags;

    // [LLPC ONLY] LLPC general options. Max length of the option is 256. for example: Disable Loop unroll:
    // -pragma-unroll-threshold=1 Enable si-scheduler: -enable-si-scheduler Please see amdllpc -help or
    // -help-hidden for detail
    char llpcOptions[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Controls whether the Device shader cache should be used to try to avoid redundant shader compiles.
    ShaderCacheMode shaderCacheMode;

    // This option is valid when EnableDropPipelineBinaryInst is set to true. It should be specified with
    // the hex value to mask DropPipelineBinaryInstToken. For example:
    // DropPipelineBinaryInstMask,0xFFFF0000
    uint32_t dropPipelineBinaryInstMask;

    // Controls whether the pipeline compiler enables internal pipeline caching. This also allows the
    // Vulkan application to get a Vulkan Pipeline Cache object based on internal caches, without creating
    // an application-managed Vulkan Pipeline Cache. (Default: TRUE) Related environment variables
    // AMD_ARCHIVE_DISK_CACHE_PATH: Path to where archive file is to be stored (optional)
    // AMD_ARCHIVE_APP_PREFIX     : Fixed prefix string for generated archive file name (optional)
    bool usePalPipelineCaching;

    // Controls whether the pipeline compiler enables Pal's archive-file based caching for internal
    // pipelines. This value can be overwritten by environment variable
    // AMD_VK_ENABLE_INTERNAL_PIPELINECACHING_TO_DISK. Related environment variables
    // AMD_ARCHIVE_DISK_CACHE_PATH: Path to where archive file is to be stored (optional)
    // AMD_ARCHIVE_APP_PREFIX     : Fixed prefix string for generated archive file name (optional)
    bool enableInternalPipelineCachingToDisk;

    // Controls whether a pipeline cache object is allowed to be created via vkCreatePipelineCache in
    // addition to the cache residing within the pipeline compiler. (Default: TRUE)
    bool allowExternalPipelineCacheObject;

    // Controls whether to use existing, compiled runtime shader pipeline caches. (Default: TRUE)
    bool usePipelineCacheInitialData;

    // Environment variable to check for to enable Pal Pipeline Caching. This allows launcher applications
    // to dynamically control whether we cache pipleline ELFs or not. When converted to an integer any 0
    // value will be treated as False, and any non-zero value will be treated as true. Functionally
    // equivalent to setting UsePalPipelineCaching = True/False
    char pipelineCachingEnvironmentVariable[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Allow use of default pipeline cache location.
    bool usePipelineCachingDefaultLocation;

    // Default sub folder to write PAL pipeline cache if not specified by environment variable
    // AMD_VK_PIPELINE_CACHE_PATH.
    char pipelineCachingDefaultLocation[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // The size of PipelineCachingDefaultLocation is limited to (default 10GB).
    uint64_t pipelineCacheDefaultLocationLimitation;

    // Controls whether the cache directory is cleaned up by xgl driver
    bool allowCleanUpCacheDirectory;

    // Driver will delete files from oldest to (oldest + Threshold). The threshold unit is seconds. Default
    // is 86400
    uint64_t thresholdOfCleanUpCache;

    // PAL Compressing Cache Layer
    PipelineCacheCompression pipelineCacheCompression;

    // Use high compression codec
    bool pipelineCacheUseHighCompression;

    // Filter which types of pipeline dump are disabled. These options can be used to dump pipelines of a
    // specific type. By default, all the pipelines are logged.
    PipelineDumpFilters filterPipelineDumpByType;

    // If non-zero, only dump the pipeline with this compiler hash.
    uint64_t filterPipelineDumpByHash;

    // Use PSO api hash as pipeline dump file name
    bool dumpPipelineWithApiHash;

    // If true, duplicate pipelines will be dumped to a file with a numeric suffix attached to the filename
    // to distinguish each copy of the pipeline.
    bool dumpDuplicatePipelines;

    // If it is not 0, Dump pipeline compile and cache hit statistic info in
    // <PipelineDumpDir>/PipelineCacheStat.txt, and the number of DumpPipelineCompileCacheMatrix is used to
    // determine the update frequency.
    uint32_t dumpPipelineCompileCacheMatrix;

#if VKI_RAY_TRACING
    // Control Legacy/Refactored raytracing and Continuations
    LlpcRaytracingMode llpcRaytracingMode;
#endif

#if VKI_RAY_TRACING
    // Continuation flags
    uint32_t cpsFlags;
#endif

#if VKI_RAY_TRACING
    // Mask for enabling SPIR-V pass for internal ray tracing pipelines. The bit is corresponding to the
    // enum defined in gpurt header.
    uint64_t rtInternalPipelineSpvPassMask;
#endif

#if VKI_RAY_TRACING
    // Enable ray tracing counters. Written to the directory specified by RtDumpDir. Press the
    // RtCaptureHotKey to dump when enabled.
    TraceRayCounterMode rtTraceRayCounterMode;
#endif

#if VKI_RAY_TRACING
    // Thread group size in x-dimension for ray tracing. This value is ignored if
    // RaytracingFlattenThreadGroupSize is not 0.
    uint32_t rtThreadGroupSizeX;
#endif

#if VKI_RAY_TRACING
    // Thread group size in y-dimension for ray tracing. This value is ignored if
    // RaytracingFlattenThreadGroupSize is not 0.
    uint32_t rtThreadGroupSizeY;
#endif

#if VKI_RAY_TRACING
    // Thread group size in z-dimension for ray tracing. This value is ignored if
    // RaytracingFlattenThreadGroupSize is not 0.
    uint32_t rtThreadGroupSizeZ;
#endif

#if VKI_RAY_TRACING
    // Ray tracing ThreadGroup Size in mode which flatten width and height. 0 indicates this mode is off.
    // Otherwise, it is on and indicates the size in x-dimension of thread group size. If the mode is on,
    // RaytracingThreadGroupSizeX/Y/Z are ignored.
    uint32_t rtFlattenThreadGroupSize;
#endif

#if VKI_RAY_TRACING
    // Maximum trace ray loop iteration count when TraceRayProfileForceMaxIteration is set.
    uint32_t rtProfileMaxIteration;
#endif

#if VKI_RAY_TRACING
    // Trace ray profile flags
    TraceRayProfileFlags rtTraceRayProfileFlags;
#endif

#if VKI_RAY_TRACING
    // Max trace ray recursion depth
    uint32_t rtMaxRayRecursionDepth;
#endif

#if VKI_RAY_TRACING
    // Indicate which stages should use indirect call for recursive ray-tracing pipeline or inlining is
    // disabled. This flag is a hint to compiler, final indirect call stages may different with initial
    // setting.
    uint32_t rtIndirectStageMask;
#endif

#if VKI_RAY_TRACING
    // Target occupancy per CU for indirect shaders. (0.0 = No Limit, 1.0 = Max Occupancy)
    float indirectCallTargetOccupancyPerSimd;
#endif

#if VKI_RAY_TRACING
    // Max number of VGPRs for unified ray tracing shaders (0xFFFFFFFF = No Limit)
    uint32_t rtUnifiedVgprLimit;
#endif

#if VKI_RAY_TRACING
    // Encode flags into pointer bits
    bool rtEnableNodePointerFlags;
#endif

#if VKI_RAY_TRACING
    // Box sorting heuristic
    BoxSortingMode boxSortingHeuristic;
#endif

#if VKI_RAY_TRACING
    // Mode for which interior box nodes in BLAS use fp16 bounding boxes
    Fp16BoxNodesInBlasMode rtFp16BoxNodesInBlasMode;
#endif

#if VKI_RAY_TRACING
    // Require the AllowCompaction flag for fp16BoxNodesInBlasMode to take effect.
    bool fp16BoxNodesRequireCompactionFlag;
#endif

#if VKI_RAY_TRACING
    // Allow fp16BoxNodesInBlasMode to take effect in updatable BVHs
    bool rtAllowFp16BoxNodesInUpdatableBvh;
#endif

#if VKI_RAY_TRACING
    // Surface area (sa) threshold used by Fp16BoxNodesInBlasMode mode DxcFp16BoxNodesInBlasModeMixed. An
    // interior BLAS node is converted from fp32 to fp16 when (saAsFp16 < (threshold * saAsFp32)). A value
    // of 0 means use the default 1.5. Value is clamped from 1.0f - 8.0f
    float rtFp16BoxNodesInBlasModeMixedThreshold;
#endif

#if VKI_RAY_TRACING
    // Enable Top Down Build in TLAS
    bool rtEnableTopDownBuild;
#endif

#if VKI_RAY_TRACING
    // Enable Rebraid in TLAS
    RebraidType rtEnableTreeRebraid;
#endif

#if VKI_RAY_TRACING
    // Max top down build instances
    uint32_t maxTopDownBuildInstances;
#endif

#if VKI_RAY_TRACING
    // Enable Triangle Splitting
    bool rtEnableTriangleSplitting;
#endif

#if VKI_RAY_TRACING
    // Triangle Splitting Factor
    float rtTriangleSplittingFactor;
#endif

#if VKI_RAY_TRACING
    // If RtEnableTriangleSplitting is enabled, this setting will limit the maximum number of splits per
    // triangle. A value=0 disables the setting.
    uint32_t rtTriangleSplittingBudgetPerTriangle;
#endif

#if VKI_RAY_TRACING
    // If RtEnableTriangleSplitting is enabled, this factor will affect the priority in triangle splitting.
    float rtTriangleSplittingPriority;
#endif

#if VKI_RAY_TRACING
    // Enable merged encode and build dispatch.
    bool enableMergedEncodeBuild;
#endif

#if VKI_RAY_TRACING
    // Enable merged encode and update dispatch.
    bool enableMergedEncodeUpdate;
#endif

#if VKI_RAY_TRACING
    // Enable Morton Code 30 bits
    bool rtEnableMortonCode30;
#endif

#if VKI_RAY_TRACING
    // Enable Variable Bits Morton Codes - Selects the largest axis per bit rather than rotating xyzxyz
    bool enableVariableBitsMortonCodes;
#endif

#if VKI_RAY_TRACING
    // Enable Prefix Scan with Decoupled Look-back
    bool rtEnablePrefixScanDlb;
#endif

#if VKI_RAY_TRACING
    // Set which BVH build flags are required to enable triangle compression when TriangleCompressionMode
    // is Auto.
    TriangleCompressionAutoMode rtTriangleCompressionAutoMode;
#endif

#if VKI_RAY_TRACING
    // Ray tracing pipeline compile mode. (Pending implementation)
    RtCompileMode rtCompileMode;
#endif

#if VKI_RAY_TRACING
    // Max RayGen shaders in state object to use Unified pipeline before falling back to indirect
    uint32_t maxUnifiedRayGenShaders;
#endif

#if VKI_RAY_TRACING
    // Max non RayGen shaders to inline in Unified pipeline before falling back to indirect
    uint32_t maxUnifiedNonRayGenShaders;
#endif

#if VKI_RAY_TRACING
    // Max total size in bytes of shaders to inline in Unified pipeline before falling back to indirect
    uint32_t maxTotalSizeOfUnifiedShaders;
#endif

#if VKI_RAY_TRACING
    // Percentage of LDS to use for traversal stack vs. LDS spilling for indirect AnyHit/Intersection
    // shaders, when EnableOptimalLdsStackSizeForIndirect = true and EnableLdsSpilling = true. The LDS
    // stack size calculated is clamped to a power of 2.
    float ldsStackSizeVsSpillingRatio;
#endif

#if VKI_RAY_TRACING
    // Default LDS traversal stack size per thread in DWORDs, when EnableOptimalLdsStackSizeForUnified /
    // EnableOptimalLdsStackSizeForIndirect = false. It is clamped to a power of 2.
    uint32_t ldsStackSize;
#endif

#if VKI_RAY_TRACING
    // Enable spilling to LDS instead of scratch for indirect functions.
    bool enableLdsSpilling;
#endif

#if VKI_RAY_TRACING
    // Compiles unified pipeline, finds the number of VGPRs needed and sets the appropriate LDS traversal
    // stack size. Could result in recompilation of unified pipeline.
    bool enableOptimalLdsStackSizeForUnified;
#endif

#if VKI_RAY_TRACING
    // Sets the appropriate LDS traversal stack size for indirect pipelines based on
    // IndirectCallTargetOccupancyPerSimd.
    bool enableOptimalLdsStackSizeForIndirect;
#endif

#if VKI_RAY_TRACING
    // Enable BVH BuildStage Counters
    bool enableBvhBuildDebugCounters;
#endif

#if VKI_RAY_TRACING
    // Enable Insert Barriers in BuildAccelerationStructure
    bool enableInsertBarriersInBuildAs;
#endif

#if VKI_RAY_TRACING
    // Mark appropriate indirect function calls as uniform with no return.
    bool enableUniformNoReturn;
#endif

#if VKI_RAY_TRACING
    // Enable reduced linkage across indirect call sites. Driver determines function parameter visibility
    // (wherever possible) and removes unused parameters.
    bool enableReducedLinkageOpt;
#endif

#if VKI_RAY_TRACING
    // Force using spill table for ray tracing root signatures. This will ensure all the root signatures
    // are compatible.
    bool forceUseSpillTableForRayTracingPipelineLayouts;
#endif

#if VKI_RAY_TRACING
    // Modifies triangle compression algorithm if AccelerationStructureType is set to the HW-supported
    // format DxcAccelTypeBVH4.
    TriangleCompressionMode rtTriangleCompressionMode;
#endif

#if VKI_RAY_TRACING
    // Use a cost calculation when batching triangles for pair compression.
    bool enablePairCompressionCostCheck;
#endif

#if VKI_RAY_TRACING
    // Override the BVH build mode for all build types
    BvhBuildModeOverride rtBvhBuildModeOverride;
#endif

#if VKI_RAY_TRACING
    // Override the BVH build mode for BLAS
    BvhBuildMode bvhBuildModeOverrideBlas;
#endif

#if VKI_RAY_TRACING
    // Override the BVH build mode for TLAS
    BvhBuildMode bvhBuildModeOverrideTlas;
#endif

#if VKI_RAY_TRACING
    // BVH build mode for default acceleration structure builds
    BvhBuildMode rtBvhBuildModeDefault;
#endif

#if VKI_RAY_TRACING
    // BVH build mode for acceleration structure builds for fast trace
    BvhBuildMode rtBvhBuildModeFastTrace;
#endif

#if VKI_RAY_TRACING
    // BVH build mode for fast acceleration structure builds
    BvhBuildMode rtBvhBuildModeFastBuild;
#endif

#if VKI_RAY_TRACING
    // Disable validating image SRD type in shader code. Only in ray tracing shader code. Image resource
    // type checking is neccessary depending on the HW.
    bool disableRayTracingImageResourceTypeCheck;
#endif

#if VKI_RAY_TRACING
    // Maximum number of waves per CU for RT workloads.
    float maxWavesPerCu;
#endif

#if VKI_RAY_TRACING
    // Maximum number of thread groups per CU for RT workloads.
    uint32_t maxThreadGroupsPerCu;
#endif

#if VKI_RAY_TRACING
    // The number of threadgroups to schedule on a single compute unit before moving to the next compute
    // unit. 0 selects optimal default.
    uint32_t tgScheduleCountPerCu;
#endif

#if VKI_RAY_TRACING
    // Enable ray tracing shader inlining into trace shader.  Note: The driver can only inline shaders that
    // do not call TraceRays() and and share the same local root signature.
    uint32_t shaderInlineFlags;
#endif

    // Re-routes all compute work to a universal queue internally.
    bool useUniversalAsComputeQueue;

#if VKI_RAY_TRACING
    // BVH build mode for default acceleration structure host builds
    BvhCpuBuildMode rtBvhCpuBuildMode;
#endif

#if VKI_RAY_TRACING
    // Enable update parallel optimization during acceleration structure builds
    bool rtEnableUpdateParallel;
#endif

#if VKI_RAY_TRACING
    // Enable parallel BVH build (no barriers)
    bool rtEnableBuildParallel;
#endif

#if VKI_RAY_TRACING
    // When the LBVH builder is selected, enable the Fast LBVH path.
    bool rtEnableFastLbvh;
#endif

#if VKI_RAY_TRACING
    // Waves per SIMD to launch for parallel build. 0 chooses the default.
    uint32_t buildParallelWavesPerSimd;
#endif

#if VKI_RAY_TRACING
    // Enable Acquire/release-based barrier interface if PAL reports the ASIC supports it.
    bool rtEnableAcquireReleaseInterface;
#endif

#if VKI_RAY_TRACING
    // Enable fused instance node for BVH builder
    bool enableFusedInstanceNode;
#endif

    // Thread Group size to use when calling DispatchRays
    uint32_t dispatchRaysThreadGroupSize;

#if VKI_RAY_TRACING
    // Dump built acceleration stats. (Pending implementation)
    bool rtEnableBuildAccelStructStats;
#endif

#if VKI_RAY_TRACING
    // Enable indirect functions calling convention. A function with convention 1 should call functions
    // with convention 2, and convention 2 should call convention 3. Each level will have more callee saved
    // SGPRs. So the calling convention hierarchy is: (1) Raygen (2) TraceRay, Callable (3) AnyHit,
    // Intersection, ClosestHit, Miss.
    IndirectConvention indirectCallConvention;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect Raygen shaders
    uint32_t indirectCalleeRaygen;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect Miss shaders
    uint32_t indirectCalleeMiss;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect ClosestHit shaders
    uint32_t indirectCalleeClosestHit;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect AnyHit shaders
    uint32_t indirectCalleeAnyHit;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect Intersection shaders
    uint32_t indirectCalleeIntersection;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect Callable shaders
    uint32_t indirectCalleeCallable;
#endif

#if VKI_RAY_TRACING
    // Number of callee saved registers for indirect TraceRays shader
    uint32_t indirectCalleeTraceRays;
#endif

#if VKI_RAY_TRACING
    // When true, the payload structs will be referenced by their pointer and not their location ID.
    bool ignorePayloadLocations;
#endif

#if VKI_RAY_TRACING
    // Enable Remapping BVH2 Data from ScratchBuffer to ResultBuffer
    bool enableRemapScratchBuffer;
#endif

#if VKI_RAY_TRACING
    // Compile pipeline library as a ShaderLibrary.
    bool rtEnableCompilePipelineLibrary;
#endif

#if VKI_RAY_TRACING
    // Enable ray tracing acceleration structure indirect build
    bool rtEnableAccelStructIndirectBuild;
#endif

#if VKI_RAY_TRACING
    // Determines if the driver performs swizzling logic on the thread + group indices for compute shaders
    // that use the ray query feature.
    bool rtEnableRayQueryCsSwizzle;
#endif

#if VKI_RAY_TRACING
    // Swizzling mode on the thread + group indices for compute shaders that use the ray query feature.
    ThreadGroupSwizzleMode rayQueryCsSwizzle;
#endif

#if VKI_RAY_TRACING
    // Determines if the driver performs swizzling logic on the thread group indices used for ray tracing
    // shaders. When this is false, a standard row major pattern is used.
    bool rtEnableDispatchRaysOuterSwizzle;
#endif

#if VKI_RAY_TRACING
    // Determines if the driver performs swizzling logic on the thread indices inside ray tracing thread
    // groups. When this is false, a standard row major pattern is used.
    bool rtEnableDispatchRaysInnerSwizzle;
#endif

#if VKI_RAY_TRACING
    // The size of outer tile for ray tracing shader thread swizzling.
    uint32_t rtOuterTileSize;
#endif

#if VKI_RAY_TRACING
    // Enable ray tracing support
    bool enableRaytracingSupport;
#endif

#if VKI_RAY_TRACING
    // Force software emulated RTIP level.
    EmulatedRtIpLevel emulatedRtIpLevel;
#endif

#if VKI_RAY_TRACING
    // Length percentage to open a node when doing top-down build with rebraid enabled.
    float rebraidLengthPercentage;
#endif

#if VKI_RAY_TRACING
    // This factor decides how much more memory to allocate when doing top-down build with rebraid enabled.
    uint32_t rebraidFactor;
#endif

#if VKI_RAY_TRACING
    // Number of size bits in morton codes.  [0-8] bits.
    uint32_t numMortonSizeBits;
#endif

#if VKI_RAY_TRACING
    // Nearest neighbour search radius during PLOC.
    uint32_t plocRadius;
#endif

#if VKI_RAY_TRACING
    // Automatically skip procedural node (AABB) leaf intersections if the pipeline has no AABB hit groups
    bool rtAutoSkipAabbIntersections;
#endif

#if VKI_RAY_TRACING
    // Emit Ray Tracing Shader Data Token
    bool rtEmitRayTracingShaderDataToken;
#endif

#if VKI_RAY_TRACING
    // Enable using LDS for function arguments. This is enabled for non-recursive indirect pipelines only
    bool enableLdsFuncArguments;
#endif

#if VKI_RAY_TRACING
    // Disables compatibility check of the src acceleration structure to the current device at
    // deserializing stage.
    bool disableAsCompatibilityCheck;
#endif

#if VKI_RAY_TRACING
    // Group BVH builds and updates based on explicit app-provided batches or our own implicit batches.
    BatchBvhModes batchBvhBuilds;
#endif

    // Triggers a CmdBarrier call after any command in the given mask.  The barrier behavior is controlled
    // by the other DbgBarrierPost* settings in this category.  Requires VK_ENABLE_DEBUG_BARRIERS=1 to take
    // effect. 0x8FFFFFFF: All commands (heavyweight option)
    uint64_t dbgBarrierPostCmdEnable;

    // For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the barrier will
    // wait. HwPipeTop is the heavy weight option.
    uint32_t dbgBarrierPostWaitPipePoint;

    // For post-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the barrier is
    // signaled. HwPipeBottom is the heavy weight option.
    uint32_t dbgBarrierPostSignalPipePoint;

    // For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source mask.
    uint32_t dbgBarrierPostCacheSrcMask;

    // For post-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination mask.
    uint32_t dbgBarrierPostCacheDstMask;

    // Triggers a CmdBarrier call before any command in the given mask.  The barrier behavior is controlled
    // by the other DbgBarrierPre* settings in this category.  Requires VK_ENABLE_DEBUG_BARRIERS=1 to take
    // effect. For further documentation, consult the corresponding DbgBarrierPostCmdEnable command.
    uint64_t dbgBarrierPreCmdEnable;

    // For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the barrier will
    // wait. For further documentation, consult DbgBarrierPostWaitPipePoint.
    uint32_t dbgBarrierPreWaitPipePoint;

    // For pre-cmd barriers, this flag describes the PAL HwPipePoint pipeline stage where the barrier is
    // signaled. For further documentation, consult DbgBarrierPostSignalPipePoint.
    uint32_t dbgBarrierPreSignalPipePoint;

    // For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags source mask. For further
    // documentation, consult DbgBarrierPostCacheSrcMask.
    uint32_t dbgBarrierPreCacheSrcMask;

    // For pre-cmd barriers, this flag describes the PAL CacheCoherencyUsageFlags destination mask. For
    // further documentation, consult DbgBarrierPostCacheDstMask.
    uint32_t dbgBarrierPreCacheDstMask;

    // Forced non-uniform resource index on all descriptor array indexing.
    uint32_t forceNonUniformDescriptorIndex;

    // Force command buffer based barrier queue usage. Default Value: SkipDstCacheInv | AvoidCpuMemoryCoher
    uint32_t resourceBarrierOptions;

    // Flags to describe strategies of avoiding barrier operations. These are illegal optimizations
    // according to the Vulkan spec but may be acceptable for some applications
    uint32_t barrierFilterOptions;

    // Options for forcing image sharing mode
    uint32_t forceImageSharingMode;

    // The number of pipeline cache count we treat as excessive and thus a smaller internal implementation
    // is used for pipeline cache.
    uint32_t excessivePipelineCacheCountThreshold;

    // The expected number of pipeline cache entries when ExcessivePipelineCacheCountThreshold is reached.
    uint32_t expectedPipelineCacheEntries;

    // If not UINT_MAX, this PAL enumerated device index will always be returned as the first enumerated
    // physical device.
    uint32_t enumPreferredDeviceIndex;

    // Force VkPhysicalDeviceFeatures::robustBufferAccess.
    FeatureEnableMode robustBufferAccess;

    // Disables wave64 support. Selected waves default to wave32 and wave size tuning is disabled.
    uint32_t deprecateWave64;

#if VKI_RAY_TRACING
    // Enable Merge Sort for Morton Code sorting - If False, the default Radix Sort is used.
    bool enableMergeSort;
#endif

#if VKI_RAY_TRACING
    // Number of Rebraid Iterations
    uint32_t numRebraidIterations;
#endif

#if VKI_RAY_TRACING
    // Rebraid Quality Heuristic Type
    RebraidQualityHeuristicType rebraidQualityHeuristicType;
#endif

#if VKI_RAY_TRACING
    // Fast BVH Build with no Morton Code sorting. Applies to BVHs with up to a wave size number of
    // primitives.
    uint32_t fastBuildThreshold;
#endif

#if VKI_RAY_TRACING
    // Enable pair compression in early build stage, i.e., During Encode phase.
    bool enableEarlyPairCompression;
#endif

#if VKI_RAY_TRACING
    // Triangle pair search radius during EarlyPairCompression.
    uint32_t trianglePairingSearchRadius;
#endif

#if VKI_RAY_TRACING
    // LBVH Build when number of primitives is below the threshold. Threshold does not apply when set to 0.
    uint32_t lbvhBuildThreshold;
#endif

    // Max number of VGPRs for indirect shaders (0xFFFFFFFF = uses indirectCallTargetOccupancyPerSimd)
    uint32_t rtIndirectVgprLimit;

#if VKI_RAY_TRACING
    // Force rebuild for acceleration structure updates.
    ForceRebuildForUpdatesModes forceRebuildForUpdates;
#endif

    // Allows instance-level functions to be queried using vkGetDeviceProcAddr.
    bool lenientInstanceFuncQuery;

    // Determines where the vkAppProfile.txt file will be written to. This file contains  the app profile
    // enumeration index.
    char appProfileDumpDir[DD_SETTINGS_MAX_PATH_SIZE];

    // Dumping options for working with application profiles
    uint32_t appProfileDumpMask;

    // Enable PRT feature in general. The detailed feature set is decided according to caps reported by
    // Pal.
    bool optEnablePrt;

    // Limit the number of waves in flight per compute unit. This can be used to throttle async compute
    // workloads so that they don't starve the universal queue.
    uint32_t asyncComputeQueueMaxWavesPerCu;

    // Limit the number of async compute queues that are reported.
    uint32_t asyncComputeQueueLimit;

    // Mask the sample counts returned in vkPhysicalDeviceLimits and vkGetPhysicalDeviceImageProperties
    // (OriginalValue & ThisValue). This setting does not actually affect support for sample counts, only
    // what is returned to the application. This value should be a combination of VKSampleCountFlags
    uint32_t limitSampleCounts;

    // Always report HDR formats (If monitor supports them) to the application.
    bool alwaysReportHdrFormats;

    // Emit 64-bit AMDIL CRC to SQTT.
    bool enableEmitSqttFunctionCrc;

    // Defines the default behavior for image resource type checking within the shader. The driver may
    // override this behavior on a per-app and per-shader basis.
    bool disableImageResourceTypeCheck;

    // Old calculation only use pci bdf (busNumber, deviceNumber, functionNumber) to compose the UUID.
    bool useOldDeviceUuidCalculation;

    // Specify whether shading rate image can be created as a linear image. For Navi2x+ IPs, the HW
    // requires that shading rate source images must be tiled.
    bool exposeLinearShadingRateImage;

    // Specify whether to skip queue creation priority failures
    bool ignoreDeviceQueuePriorityFailures;

    // Controls PWS enable mode: disabled, fully enabled or partially enabled. Only takes effect if HW
    // supports PWS.
    PwsMode forcePwsMode;

    // Controls whether support for mesh shaders should be enabled
    bool enableMeshShaders;

    // Enable true 16-bit float and integer types
    bool enableNative16BitTypes;

    // Custom device allocation count limitation, when larger than 0.
    uint32_t memoryCustomDeviceAllocationCountLimit;

    // All VkMemory memory objects will have the following the GPU VA base address alignment.
    uint32_t memoryBaseAddrAlignment;

    // On 32-bit Windows builds, the following GPU VA base alignment is used for host-visible memory types
    // instead of MemoryBaseVaAlign.
    uint32_t memoryBaseAddrAlignmentCpuVisibleWin32;

    // Default priority of all VkMemory objects as two hex digits.  The first (most-significant) digit
    // defines the priority level, and the second digit defines the priority offset.  Valid priority level
    // values (Pal::GpuMemPriority) are:  0: Unused 1: VeryLow 2: Low 3: Normal 4: High 5: VeryHigh. Valid
    // priority offset values (Pal::GpuMemPriorityOffset) are: 0: Offset0 (same as base level) 1: Offset1
    // 2: Offset2 3: Offset3 4: Offset4 5: Offset5 6: Offset6 7: Offset7
    uint32_t memoryPriorityDefault;

    // Priority of all VkMemory objects containing at least one image. See MemoryPriorityDefault for valid
    // values.
    uint32_t memoryPriorityImageAny;

    // Priority of all VkMemory objects containing at least one image shader-readable image. See
    // MemoryPriorityDefault for valid values.
    uint32_t memoryPriorityImageShaderRead;

    // Priority of all VkMemory objects containing at least one shader-writable (storage) image. See
    // MemoryPriorityDefault for valid values.
    uint32_t memoryPriorityImageShaderWrite;

    // Priority of all VkMemory objects containing at least one image that can be a color target. See
    // MemoryPriorityDefault for valid values.
    uint32_t memoryPriorityImageColorTarget;

    // Priority of all VkMemory objects containing at least one image that can be a depth-stencil. See
    // MemoryPriorityDefault for valid values.
    uint32_t memoryPriorityImageDepthStencil;

    // On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap budget size
    // as HeapBudgetRatioOfHeapSizeLocal% of heap size for GpuHeapLocal. Valid value is [0, 100].
    uint32_t heapBudgetRatioOfHeapSizeLocal;

    // On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap budget size
    // as HeapBudgetRatioOfHeapSizeInvisible% of heap size for GpuHeapInvisible Valid value is [0, 100].
    uint32_t heapBudgetRatioOfHeapSizeInvisible;

    // On wddm1 and linux, there's no os functionality to report memory budget. We fudge heap budget size
    // as HeapBudgetRatioOfHeapSizeNonlocal% of heap size for GpuHeapGartUswc and GpuHeapGartCacheable.
    // Valid value is [0, 100].
    uint32_t heapBudgetRatioOfHeapSizeNonlocal;

    // Override reported minImageTransferGranularity field for graphics queue families.  This is encoded as
    // a hex string of the form 0xb000zzyyxx, where 'xx', 'yy', and 'zz' are the reported transfer
    // granularities in the X, Y and Z extents respectively, and 'b' is a control flag: if 'b' is non-zero,
    // this override is applies; otherwise the standard transfer granularity is used.
    uint32_t transferGranularityUniversalOverride;

    // Override reported minImageTransferGranularity field for compute queue families.  For how this value
    // is interpreted by the driver, see the description for TransferGranularityUniversalOverride.
    uint32_t transferGranularityComputeOverride;

    // Device-local memory that is explicitly allocated by the application can tracked on a per-device and
    // per-heap basis. Once the size of a target heap is reached, VK_OUT_OF_DEVICE_MEMORY will be returned.
    // Setting this parameter to TRUE will disable such tracking by DEFAULT. This parameter can be
    // overridden by the VK_AMD_memory_overallocation_behavior device extension and specific app profiles
    // (unless MemoryDeviceOverallocationNonOverridable is set to TRUE).
    bool memoryDeviceOverallocationAllowed;

    // MemoryDeviceOverallocationAllowed can be overriden by the VK_AMD_memory_overallocation_behavior
    // device extension and specific app profiles unless this parameter is set to TRUE.
    bool memoryDeviceOverallocationNonOverridable;

    // Override reported minImageTransferGranularity field for DMA (i.e. SDMA) queue families. For how this
    // value is interpreted by the driver, see the description for TransferGranularityUniversalOverride.
    uint32_t transferGranularityDmaOverride;

    // If this option is enabled, the driver returns an extra image memory requirement. The amount of
    // memory is determined by memoryPaddingFactorForImageMemoryRequirements.This can be used while
    // capturing GFXR traces and can be helpful for DCC tuning
    bool addMemoryPaddingToImageMemoryRequirements;

    // When AddMemoryPaddingToImageMemoryRequirements setting is enabled, this value determines how much
    // extra memory is to be padded. By default, 10% extra is added.
    float memoryPaddingFactorForImageMemoryRequirements;

    // [GFX10+ only] MALL NOALLOC resource policy.
    uint32_t mallNoAllocResourcePolicy;

    // [GFX10+ only] MALL NOALLOC color target (RT) resource policy.
    uint32_t mallNoAllocCtPolicy;

    // [GFX10+ only] MALL NOALLOC shader storage resource (SSR <-> UAV) policy.
    uint32_t mallNoAllocSsrPolicy;

    // [GFX10+ only] MALL NOALLOC depth stencil resource policy.
    uint32_t mallNoAllocDsPolicy;

    // [GFX10+ only] MALL NOALLOC color target and shader storage resource (SSR <-> UAV) policy.
    uint32_t mallNoAllocCtSsrPolicy;

    // Allocations for selected heaps get redirected to local visible.
    uint32_t overrideHeapChoiceToLocal;

    // If overrideHeapChoiceToLocal is set, GpuHeapLocal is replaces requested heap use until this budget
    // is met. Valid value is [0, 100].
    uint32_t overrideHeapChoiceToLocalBudget;

    // Forces allocations for GART cacheable to be allocated as GART USWC
    bool overrideHeapGartCacheableToUswc;

    // Forces local heap size to the value specified in GBs. The setting doesn't take affect unless the
    // specified size is greater than actual heap size reported by PAL.
    uint32_t overrideLocalHeapSizeInGBs;

    // Forces the memoryBudget value used in SW addrlib to determine the minSizeBlk for textures. It must
    // be >= 0.0. When in [0.0, 1.0) addrlib uses legacy logic to decide minSizeBlk. When == 1.0 addrlib
    // uses minimizeAlign. Values > 1.0 (recommended <= 3.5) will apply memory budget algorithm to addrlib.
    // NOTE:Despite 1.5 in tests show significant texture allocation size reduction, default value 0.0
    // (legacy behavior) is recommended unless this is set for specific apps on specific ASICs
    float imageMemoryBudget;

    // for APU, set local and local invisibl heap size to 0, Force to use system memory.
    bool forceUma;

    // Enable allocation and suballocation tracking as if VK_EXT_device_memory_report is enabled, minus
    // calling any callbacks (unless the extension is actually enabled by the application and it registers
    // callbacks).
    bool simulateExtDeviceMemoryReport;

    // Enable bind tracking as if VK_EXT_device_address_binding_report is enabled, minus calling any
    // callbacks (unless the extension is actually enabled by the application and it registers callbacks).
    bool simulateExtDeviceAddressBindingReport;

    // Forces a particular AppProfile value.  The profile selected is the value of ForceAppProfileValue.
    bool forceAppProfileEnable;

    // Forces a particular AppProfile value.  This value is the integer value of the AppProfile enum.
    // Ignored unless ForceAppProfileEnable is true.
    uint32_t forceAppProfileValue;

    // Setting this to true for an app allows the driver to update image layout from
    // VK_IMAGE_LAYOUT_UNDEFINED to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL. Currently, only used for
    // AshesofTheSingularity
    bool overrideUndefinedLayoutToTransferSrcOptimal;

    // PreciseAnisoMode denotes whether preciseAniso will be enabled.
    PreciseAnisoMode preciseAnisoMode;

    // Allow to use anisotropy filtering sampling for images with single mipmap level.
    bool disableSingleMipAnisoOverride;

    // Supply the threshold value for anisotropic filtering (DisablePreciseAniso needs to be true also)
    bool useAnisoThreshold;

    // The threshold value for anisotropic filtering (DisablePreciseAniso & UseAnisoThreshold need to be
    // true also) Default value (0.25) preserves the Pal behaviour
    float anisoThreshold;

    // Controls the value of the PERF_MIP field in Sampler SRDs (DisablePreciseAniso needs to be true also)
    uint32_t samplerPerfMip;

    // Use flip hint for swapchain. Linux Only. The X Server make the final decision whether to go async
    // flip.
    bool useFlipHint;

    // If this is true, The PAL preferred present mode is ignored.
    bool ignorePreferredPresentMode;

    // Force fullscreen exclusive presents when detected safe.  The following combination of flags control
    // whether this feature is enabled for a particular OS + swapchain combination:
    uint32_t backgroundFullscreenPresent;

    // Fullscreen presents may fail due to unexpected errors, although these cases are rare. Failing a
    // fullscreen present and reattempting to acquire exclusive access causes dropped frames and screen
    // flickering.  This is a fail-safe setting that permanently disables the fullscreen present logic
    // after the given number of consecutive unexpected failures.
    uint32_t backgroundFullscreenFailureDisableCount;

    // Reset the failure count only after this many consecutive successful fullscreen presents. A large
    // value for this setting is used to guarantee that we are consistently presenting in fullscreen
    // instead of rapidly ping-ponging between fullscreen and windowed presents.
    uint32_t backgroundFullscreenSuccessResetCount;

    // When forcing fullscreen presents, this flag will ignore unexpected errors on any failed present.
    bool backgroundFullscreenIgnorePresentErrors;

    // Hints to PAL to select the appropriate tiling mode for an optimization target. 0: Balanced 1:
    // OptForSpace 2: OptForSpeed
    Pal::TilingOptMode imageTilingOptMode;

    // Controls driver adherence to the KHR_maintenance4 requirement that a VkImage's size memory
    // requirement is never greater than that of another VkImage created with a greater or equal value in
    // each of extent.width, extent.height, and extent.depth; all other creation parameters being
    // identical.
    uint32_t strictImageSizeRequirements;

    // Hints to pal to identify a preference for how this image is organized. 0: Default 1: Standard 2:
    // XMajor 3: YMajor 4: Interleaved
    Pal::ImageTilingPattern imageTilingPreference;

    // Override the ImageTilingPreference setting value for 3D images used as color attachments or shader
    // storage.
    Pal::ImageTilingPattern imageTilingPreference3dGpuWritable;

    // Enable FMASK based MSAA texture reads.
    bool enableFmaskBasedMsaaRead;

    // When Fmask based MSAA read is enabled, this can instruct il converter to optimize any fetch from
    // sampleIndex 0 to fetch from Color 0 instead. This also may eliminate any dummy fmask lookups from
    // depth surfaces.
    bool enableFmaskLookUpOptSampleIndexZero;

    // Enable high priority for descriptor memory.
    bool enableHighPriorityDescriptorMemory;

    // Disable Htile based MSAA texture reads.
    bool disableHtileBasedMsaaRead;

    // If we know that a MSAA stencil aspect isn't read as a shader resource, give PAL a hint that it's
    // okay to choose a non-TCC format.
    bool disableMsaaStencilShaderRead;

    // For MSAA color image created with usage of transfer dst, enable this optimization to avoid heavy
    // expanding.
    bool enableFullCopyDstOnly;

    // For image created with usage of transfer src, add shader_read in PAL usage if VkImageUsageFlagBits
    // in this mask is set.
    uint32_t optImgMaskToApplyShaderReadUsageForTransferSrc;

    // For image created with usage of transfer dst, add shader_write in PAL usage if VkImageUsageFlagBits
    // in this mask is set.
    uint32_t optImgMaskToApplyShaderWriteUsageForTransferDst;

    // If set, an image with color target usage bit does not implicitly allow to be in resolve_src or
    // resolve_dst layout.
    bool optColorTargetUsageDoesNotContainResolveLayout;

    // If set, a depth stencil image with transfer usage bit is implicitly allowed to be in resolve_src or
    // resolve_dst layout.
    bool forceResolveLayoutForDepthStencilTransferUsage;

    // This bitmask denotes which subset of pipeline render state is cached at the device-level. Caching
    // render state enables more efficient redundancy checking when recording command buffers.  This
    // redundancy checking is mainly limited to pipeline state that is either invisible to the API (e.g.
    // certain PAL objects) or state that the application has marked in the pipeline as non-dynamic,
    // meaning its values are programmed during pipeline bind.
    uint32_t optRenderStateCacheEnable;

    // If set, the MUTABLE flag on image is ignored.
    bool ignoreMutableFlag;

    // OptimizeCmdbufMode denotes whether pm4 optimizations will be enabled.
    OptimizeCmdbufMode optimizeCmdbufMode;

    // If set, shaders are prefetched to warm L2 shader cache.
    bool prefetchShaders;

    // Keep prefetch enabled for ACE shaders.
    bool enableAceShaderPrefetch;

    // If not UINT_MAX, sets the minimum BPP of surfaces which may have DCC enabled.
    uint32_t dccBitsPerPixelThreshold;

    // If not default, force enables DCC on the basis of resource and/or BPP. NOTE: To force enable shader
    // storage DCC, at least one of 2D/3D and one of CA/non-CA need to be set
    uint32_t forceEnableDcc;

    // Provides a hint to PAL that PAL should disable color compression on surfaces that are smaller than
    // or equal to this setting (setting * setting) in size.
    uint32_t disableSmallSurfColorCompressionSize;

    // If not default, force convert D32 or D24 to D16 for depth image
    uint32_t forceLowPrecisionDepthImage;

    // This bit limits CB color cache fetch to 256B on cache miss, regardless of sector size.
    bool limitCbFetch256B;

    // Enables the use of Pal::CmdReleaseThenAcquire(), Pal::CmdRelease() and Pal::CmdAcquire() barrier
    // interfaces on supported ASICs (gfx9+).
    bool useAcquireReleaseInterface;

    // Using sync token is enabled.
    bool syncTokenEnabled;

    // Enable Shader Profiling for Power (SPP).  The gist of the initial version of this feature is that we
    // will profile important  applications to determine which shaders are heavily memory bound, then use
    // these profiles  to program the RLC to dynamically reduce engine clocks when running such
    // shaders.This  should result in power savings with a limited perf impact.
    bool enableSpp;

    // Enable support for format D24_UNORM_S8_UINT and X8_D24_UNORM_PACK32.
    bool enableD24S8;

    //  Disables Display Dcc on presentable surface.
    DisplayableDcc disableDisplayDcc;

    // Specifies the maximum threshold in bytes for linear transfer commands to use CP DMA, which have less
    // overhead than CS/Gfx copies, but also less throughput for large copies.
    uint32_t cpDmaCmdCopyMemoryMaxBytes;

    // Limits the number of command buffers that will be chained together; reduce to prevent problems due
    // to long running submits or to minimize the scope of commands being debugged.
    uint32_t cmdBufBatchedSubmitChainLimit;

    // Disables all implicit invariant marking of exports, which in turn disables MUL/ADD -> FMA. This
    // option is legal but may cause issues if applications are sensitive to FMA influencing some export
    // results.
    bool disableImplicitInvariantExports;

    // [LLPC ONLY] Disables forward propagation of NoContract flags. This option is legal but may cause
    // issues if applications are sensitive to FMA influencing results.
    bool disableForwardPropagateNoContract;

    // This value denotes whether using CmdClearBoundAttachments/CmdClearBoundDepthStencilTargets for
    // subpass load op clears or not.
    bool subpassLoadOpClearsBoundAttachments;

    // Move all load operation clears from the beginning of each subpass to beginning of render pass.
    bool renderPassClearUpfront;

    // Set default AllGpuRenderState before pipeline bind.
    bool preBindDefaultState;

    // Force all compute shaders to have swizzled thread groups.
    ThreadGroupSwizzleMode forceCsThreadGroupSwizzleMode;

    // Originally SIMDs cover 16x2 regions, after swizzling they cover 8x4 regions.
    bool forceCsThreadIdSwizzling;

    // Override ThreadGroupSizeX for wave32 and wave64
    ThreadGroupSizeX overrideThreadGroupSizeX;

    // Override ThreadGroupSizeY for wave32 and wave64
    ThreadGroupSizeY overrideThreadGroupSizeY;

    // Override ThreadGroupSizeZ for wave32 and wave64
    ThreadGroupSizeZ overrideThreadGroupSizeZ;

#if VKI_RAY_TRACING
    // Force all ray tracing shaders compiled in unified mode to have swizzled thread groups.
    ThreadGroupSwizzleMode forceRtThreadGroupSwizzleMode;
#endif

    // Write graphics pipeline push descriptors to user data registers unless the total user data count
    // exceeds this value. Maximum value is MaxBindingRegCount (96)
    uint32_t gfxInlinePushDescriptorUserDataLimit;

    // Write compute pipeline push descriptors to user data registers unless the total user data count
    // exceeds this value. Maximum value is MaxBindingRegCount (96)
    uint32_t csInlinePushDescriptorUserDataLimit;

    // Enable support for alternating compute shader thread group ordering.
    bool enableAlternatingThreadGroupOrder;

    // If true, enables RE_Z after EARLY_Z. Valid only for pixel shaders.
    bool allowReZ;

    // If true, disables ReZ for pipelines that only read/write depth
    bool disableDepthOnlyReZ;

    // Allows use AC01 fast clears. Please also check setting: Ac01WaState.
    bool ac01WaNotNeeded;

    // Potentially issue load op fast clears for load op don't care color attachments for subpasses with at
    // least this many color attachments.
    uint32_t minColorAttachmentsForOptionalClears;

    // Potentially issue load op fast clears for load op don't care color attachments for subpasses with at
    // least this may subpasses.
    uint32_t minSubpassesForOptionalClears;

    // Enable variable rate shading on supported hardware.
    bool enableVariableRateShading;

#if VKI_GPU_DECOMPRESS
    // Enable GPU decompress pass for astc/etc image, it is on the vkCopyBufferToImage, and not safe
    // depending on application.
    bool enableShaderDecode;
#endif

#if VKI_GPU_DECOMPRESS
    // Enable BC3 encoder to convert ASTC/ETC2 to BC3 format.
    uint32_t enableBc3Encoder;
#endif

    // Determines the string that's used to trigger a start-frame delimiter via
    // vkQueueInsertDebugUtilsLabelEXT. This string is "AmdFrameBegin" by default.
    char devModeStartFrameDebugUtilsLabel[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Determines the string that's used to trigger an end-frame delimiter via
    // vkQueueInsertDebugUtilsLabelEXT. This string is "AmdFrameEnd" by default
    char devModeEndFrameDebugUtilsLabel[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Injects a queue WaitIdle() at the end of a debug utils end-frame delimiter to avoid overlapping
    // frames.
    bool devModeBlockingEndFrameDebugUtils;

    // Determines the pipeline binary max size limit (in KB) used by the PipelineUriService when injecting
    // pipeline binaries back into the driver. The limit is 256KB by default.
    uint32_t devModePipelineUriServicePostSizeLimit;

    // This controls whether elf files placed in DevModeElfReplacementDirectory will be read.
    bool devModeElfReplacementDirectoryEnable;

    // Elf files placed within this directory will be cached and replace corresponding pipeline binaries as
    // they are created. Elf files within this directory should follow this nomenclature: "[exe name]_[hash
    // of pipeline being replaced].elf"
    char devModeElfReplacementDirectory[DD_SETTINGS_MAX_PATH_SIZE];

    // This controls whether RGP traces will include shader code of created pipelines.
    bool devModeShaderIsaDbEnable;

    // This controls whether queue operations are timed during RGP traces.
    bool devModeQueueTimingEnable;

    // This controls what kind of SQTT instrumentation marker data is output from the driver. Note that
    // this only fine-tunes instrumentation: the master toggle for SQTT is always whether developer mode is
    // enabled.  General SQTT data (event, wave, instruction) is also generated independent of this setting
    // if SQTT is enabled.
    uint32_t devModeSqttMarkerEnable;

    // If true, SQTT support is disabled and all RGP traces will automatically fail.
    bool devModeSqttForceDisable;

    // If true, a CPU device wait idle is executed prior to starting and ending a trace. PLEASE NOTE: This
    // is currently not thread safe and may result in crashes. It is only included as a debugging option.
    bool devModeSqttWaitIdle;

    // If true, inserts a full pipeline flush into all hardware queues at the beginning of the last
    // preparation frame in an RGP trace.
    bool devModeSqttFlushAllQueues;

    // Maximum amount of data in bytes to capture per trace. A trace will cover a span of commands based on
    // the GpuProfilerGranularity setting. Defaults to 0, which means auto-calculate the size based on GPU
    // characteristics. Current HW requires the size be aligned to 0x1000 bytes.
    uint32_t devModeSqttGpuMemoryLimit;

    // Number of frames (present calls) to trace SQTT.
    uint32_t devModeSqttFrameCount;

    // If TRUE, DevModeSqttTrace[Begin|End]TagValues are used to override trace parameter begin/end command
    // buffer debug object tag values. This is mainly used for debugging.
    bool devModeSqttTraceBeginEndTagEnable;

    // Custom command buffer debug object tag value signifying virtual frame start.  Requires
    // DevModeSqttTraceBeginEndTagEnable.
    uint64_t devModeSqttTraceBeginTagValue;

    // Custom command buffer debug object tag value signifying virtual frame end. Requires
    // DevModeSqttTraceBeginEndTagEnable.
    uint64_t devModeSqttTraceEndTagValue;

    // If TRUE, instruction-level tracing will be enabled. DevModeSqttTargetApiPsoHash can beused to
    // specify the scope traced (full frame or individual pipeline).
    bool devModeSqttInstructionTraceEnable;

    // Target API PSO hash used to trigger instruction level tracing. Full-frame instructiontracing will be
    // enabled if set to 0x0.
    uint64_t devModeSqttTargetApiPsoHash;

    // If TRUE, the driver will block immediately after ending a trace to wait for results tocomplete
    // rather than asynchronously checking for completion during frame boundaries.
    bool devModeSqttForceBlockOnTraceEnd;

    // If non-default, this value will override the trace parameter prepare frame count, which isthe number
    // of lead frames prior to enabling SQTT that include only queue timing.
    uint32_t devModeSqttPrepareFrameCount;

    // Enable RGP trace dumping directly from the driver (in addition to sending it to RDP). This is useful
    // in situations where the network connection is very lossy.
    bool devModeEnableRgpTraceDump;

    // File where the RGP trace is dumped when DevModeEnableRgpTraceDump is set.
    char devModeRgpTraceDumpFile[DD_SETTINGS_MAX_FILE_NAME_SIZE];

    // Controls the barrier inserted during RGP tracing when instruction trace is active which stalls at
    // the end of the command buffer to ensure that instruction trace is not disabled while the pipeline
    // being traced is still in flight.  This barrier has a significant effect on frame timing.
    bool rgpInstTraceBarrierEnabled;

    // Indicate that shader parameter override is enabled - mainly used for automation
    bool overrideShaderParams;

    // Upper 64-bits of the shader hash of shader for which parameters are to be overridden
    uint64_t overrideShaderHashUpper;

    // Lower 64-bits of the shader hash of shader for which parameters are to be overridden
    uint64_t overrideShaderHashLower;

    // Shader stage for which parameters are to be overriden.
    uint32_t overrideShaderStage;

    // Override number of available VGPRs for the shader specified by overrideShaderCrcUpper/Lower
    uint32_t overrideNumVgprsAvailable;

    // Override number of waves per CU for the shader specified by overrideShaderCrcUpper/Lower
    uint32_t overrideWavesPerCu;

    // Force PAL to spill user data registers to memory for the shader specified by
    // overrideShaderCrcUpper/Lower
    bool overrideUserDataSpillThreshold;

    // Set the max LDS spill size in DWORDs for the shader specified by overrideShaderCrcUpper/Lower
    uint32_t overrideMaxLdsSpillDwords;

    // Override default setting to disable loop unrolls
    bool overrideDisableLoopUnrolls;

    // [LLPC ONLY] Use LLVM backend's SI Scheduler instead of the default scheduler
    bool overrideUseSiScheduler;

    // [LLPC ONLY] Allow automatic workgroup reconfigure to take place on compute shaders
    bool overrideReconfigWorkgroupLayout;

    // [LLPC ONLY] Disable the LLVM backend's LICM pass
    bool overrideDisableLicm;

    // [LLPC ONLY] Enable LLPC load scalarizer optimization
    bool overrideEnableLoadScalarizer;

    // [LLPC ONLY] Disable LLVM backend's code sinking
    bool overrideDisableCodeSinking;

    // [LLPC ONLY] Force Aggresive Invariant Loads.
    InvariantLoads overrideAggressiveInvariantLoads;

    // [LLPC ONLY] Force NSA Threshold Value. Valid values are 0-16, with 1 being ignored.
    uint32_t overrideNsaThreshold;

    // [LLPC ONLY] Force LLPC loop unroll count
    uint32_t overrideForceLoopUnrollCount;

    // [LLPC ONLY] Force LLPC unroll threshold
    uint32_t overrideUnrollThreshold;

    // [LLPC ONLY] Force LLPC fast math flags
    uint32_t overrideFastMathFlags;

    // [LLPC ONLY] Disable LLPC fast math flags
    uint32_t overrideDisableFastMathFlags;

    // [LLPC ONLY] Favour latency hiding over register pressure
    bool overrideFavorLatencyHiding;

    // [LLPC ONLY] Enable scalarizing of descriptor loads in waterfall loops
    bool overrideScalarizeWaterfallLoads;

    // [LLPC ONLY] Backward propagate NoContract flags to all related operation. This is a workaround for
    // SPIRV generated without sufficient NoContract flags.
    bool overrideBackwardPropagateNoContract;

    // Enable selective inlining behavior in the compiler.
    bool overrideEnableSelectiveInline;

    // Enable Subvector to look for opportunities in Wave64 mode to generate subvector code switching to
    // Wave32 mode over parts of the shader
    bool overrideEnableSubvector;

    // Set the thread-group per CU limit for compute shaders.
    uint32_t overrideCsTgPerCu;

    // Set option to disable PBB for shader specified by OverrideShaderCrcUpper and OverrideShaderCrcLower
    PipelineBinningMode overrideUsePbbPerCrc;

    // Override allowReZ for the shader specified by OverrideShaderHashUpper/Lower.
    bool overrideAllowReZ;

    // Override WaveSize for the shader specified by OverrideShaderHashUpper/Lower.
    ShaderWaveSize overrideWaveSize;

    // Override WgpMode for the shader specified by OverrideShaderHashUpper/Lower
    WgpMode overrideWgpMode;

    // Override use of NGG on a per shader basis. Default behavior to enable NGG use
    bool overrideUseNgg;

    // Override thread group swizzling on a per shader basis.
    ThreadGroupSwizzleMode overrideThreadGroupSwizzling;

    // Override thread ID swizzling on a per shader basis.
    bool overrideThreadIdSwizzle;

    // Eliminate unnecessary function load and store instructions.
    bool eliminateFuncLoadStore;

    // If this is true, resource key will include any modifications based on runtime settings. BEWARE:
    // Modifying this setting can invalidate resource optimizations if enabled for an app profile.
    bool modifyResourceKeyForAppProfile;

    // If this is true, any production app profile-installed resource optimizations are ignored.
    bool resourceProfileIgnoresAppProfile;

    // Indicate that resource parameter override is enabled - mainly used for automation
    bool overrideResourceParams;

    // The width (upper 32-bits) and height (lower 32-bits) of the resource(s) onto which the parameters
    // are to be applied. If 0, the dimensions will be matched up.
    uint64_t overrideResourceHashDimensions;

    // The API hash of the resource(s) onto which the parameters are to be applied. If 0, the API hash will
    // not be matched up.
    uint64_t overrideResourceHashCrc;

    // Force metadata to be enabled or disabled for the resource.
    DccMode overrideResourceDccOnOff;

    // Controls texture filtering optimizations exposed by CCC.
    TextureFilterOptimizationSettings vulkanTexFilterQuality;

    // Specifies the GPU ID (composed of PCI info).
    uint32_t appGpuId;

    // Disables AMD Vendor Extensions
    bool disableAmdVendorExtensions;

    // Always allocates dynamic descriptor data instead of based on VkDescriptorPoolCreateInfo.pPoolSizes
    bool alwaysAllocDynamicDescriptorData;

    // Allow for modified barrier for Implicit External Synchronization
    bool implicitExternalSynchronization;

    // Override ThreadGroupSizeX on a per shader basis.
    ShaderThreadGroupSizeX overrideShaderThreadGroupSizeX;

    // Override ThreadGroupSizeY for wave32 and wave64 on a per shader basis.
    ShaderThreadGroupSizeY overrideShaderThreadGroupSizeY;

    // Override ShaderThreadGroupSizeZ for wave32 and wave64 on a per shader basis.
    ShaderThreadGroupSizeZ overrideShaderThreadGroupSizeZ;

    // Forces the driver to disable anisotropy filter while creating samplers.
    bool forceDisableAnisoFilter;

#if VKI_RAY_TRACING
    // Forces the driver to behave as if the raytracing acceleration structure used by the application is
    // always invalid. This will cause all TraceRay() calls to result in a miss.
    bool forceInvalidAccelStruct;
#endif

#if VKI_RAY_TRACING
    // Set toss point for raytracing.
    RtTossPointEnums rtTossPoint;
#endif

#if VKI_RAY_TRACING
    // Override the maximum extent of the ray, this value overrides the application specified rayDesc.tMax
    // value.
    float rtMaxRayLength;
#endif

#if VKI_RAY_TRACING
    // GPURT GPU debug flags
    uint32_t rtGpuDebugFlags;
#endif

    // Used to wait idle on vkCreateInstance() call until a debugger is attached to running application.
    // Effective only on Windows debug builds.
    bool waitForDebugger;

    // Executable name of a Vulkan application (e.g. vkcube.exe) upon which to wait idle until a debugger
    // is attached. If empty, it applies to all Vulkan applications
    char waitForDebuggerExecutableName[DD_SETTINGS_MAX_MISC_STRING_SIZE];

    // Timeout the driver in millisecond to give debuggers a chance to load all of the symbols
    uint32_t debugTimeout;

    // Enable/Disable wait after command buffer submission
    bool waitAfterSubmit;

    // Enable printf debug functionality
    bool enableDebugPrintf;

    // Printf debug buffer size
    uint32_t debugPrintfBufferSize;

    // Enable print output for GPU hang
    bool enableHangOutput;

    // Relative directory where printf is dumped. Root directory is determined by AMD_DEBUG_DIR environment
    // variable.
    char debugPrintfDumpFolder[DD_SETTINGS_MAX_PATH_SIZE];

    // Printf debug stdout
    bool debugPrintfToStdout;

    // Support mutable descriptors
    bool supportMutableDescriptors;

    // Whether zero-initializes the allocated vram or not, Linux only
    bool initializeVramToZero;

    // Control Vsync behavior of swapchain, on Windows this key is also read from Radeon Settings
    VSyncControl vSyncControl;

    // Disables trunc_coord of sampler srd for gather4.
    bool disableTruncCoordForGather;

    // Report suboptimal presents as OutOfDate to force swapchain recreation and resume presenting
    // optimally
    bool reportSuboptimalPresentAsOutOfDate;

    // Export extension NV_compute_shader_derivatives
    bool exportNvComputeShaderDerivatives;

    // Export extension NV_device_generated_commands and NV_device_generated_commands_compute
    bool exportNvDeviceGeneratedCommands;

    // Export extension VK_EXT_image_compression_control
    bool exportImageCompressionControl;

    // [GFX10+ only] MALL RPM Views policy.
    uint32_t rpmViewsBypassMall;

    // Disable exposing image format support if image type is 3D and tiling is linear
    bool disable3dLinearImageFormatSupport;

    // skip UnMap when application repeately calling map/unmap on the same memory object to avoid extra
    // paging traffic in kernel.
    bool skipUnMapMemory;

    // Enable Graphics Pipeline Libraries
    bool enableGraphicsPipelineLibraries;

    // Enable ColorClearAutoSync that tells PAL to automatically insert any required barriers between color
    // image clears
    bool enableColorClearAutoSync;

    // Clamp the max image dimensions (width, height and depth) to the minimum of the specified value and
    // HW reported value. Useful for compatibility issues with older games running on newer HW.
    uint32_t clampMaxImageSize;


};

const uint32_t g_vulkanNumSettings = 476;

constexpr DD_SETTINGS_NAME_HASH enableDumbTransitionSyncHash = 1476239310;
constexpr const char* pEnableDumbTransitionSyncHashStr = "#1476239310";
constexpr DD_SETTINGS_NAME_HASH forceDisableGlobalBarrierCacheSyncHash = 3241750791;
constexpr const char* pForceDisableGlobalBarrierCacheSyncHashStr = "#3241750791";
constexpr DD_SETTINGS_NAME_HASH rpBarrierCheckAccessMasksHash = 1431118729;
constexpr const char* pRpBarrierCheckAccessMasksHashStr = "#1431118729";
constexpr DD_SETTINGS_NAME_HASH useSharedCmdAllocatorHash = 2695722952;
constexpr const char* pUseSharedCmdAllocatorHashStr = "#2695722952";
constexpr DD_SETTINGS_NAME_HASH useBackupCmdbufferHash = 3244085772;
constexpr const char* pUseBackupCmdbufferHashStr = "#3244085772";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorDataHeapHash = 1832694714;
constexpr const char* pCmdAllocatorDataHeapHashStr = "#1832694714";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorDataAllocSizeHash = 2667761104;
constexpr const char* pCmdAllocatorDataAllocSizeHashStr = "#2667761104";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorDataSubAllocSizeHash = 4089588998;
constexpr const char* pCmdAllocatorDataSubAllocSizeHashStr = "#4089588998";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorEmbeddedHeapHash = 46174540;
constexpr const char* pCmdAllocatorEmbeddedHeapHashStr = "#46174540";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorEmbeddedAllocSizeHash = 4049945662;
constexpr const char* pCmdAllocatorEmbeddedAllocSizeHashStr = "#4049945662";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorEmbeddedSubAllocSizeHash = 1513127512;
constexpr const char* pCmdAllocatorEmbeddedSubAllocSizeHashStr = "#1513127512";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorLargeEmbeddedAllocSizeHash = 2479020139;
constexpr const char* pCmdAllocatorLargeEmbeddedAllocSizeHashStr = "#2479020139";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorLargeEmbeddedSubAllocSizeHash = 1436000139;
constexpr const char* pCmdAllocatorLargeEmbeddedSubAllocSizeHashStr = "#1436000139";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorScratchHeapHash = 4153516452;
constexpr const char* pCmdAllocatorScratchHeapHashStr = "#4153516452";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorScratchAllocSizeHash = 3574029062;
constexpr const char* pCmdAllocatorScratchAllocSizeHashStr = "#3574029062";
constexpr DD_SETTINGS_NAME_HASH cmdAllocatorScratchSubAllocSizeHash = 3402444848;
constexpr const char* pCmdAllocatorScratchSubAllocSizeHashStr = "#3402444848";
constexpr DD_SETTINGS_NAME_HASH prefetchCommandsHash = 3391355752;
constexpr const char* pPrefetchCommandsHashStr = "#3391355752";
constexpr DD_SETTINGS_NAME_HASH padVertexBuffersHash = 535009171;
constexpr const char* pPadVertexBuffersHashStr = "#535009171";
constexpr DD_SETTINGS_NAME_HASH disableResetReleaseResourcesHash = 1002672180;
constexpr const char* pDisableResetReleaseResourcesHashStr = "#1002672180";
constexpr DD_SETTINGS_NAME_HASH threadSafeAllocatorHash = 1135278793;
constexpr const char* pThreadSafeAllocatorHashStr = "#1135278793";
constexpr DD_SETTINGS_NAME_HASH cacheUuidNamespaceHash = 2141797641;
constexpr const char* pCacheUuidNamespaceHashStr = "#2141797641";
constexpr DD_SETTINGS_NAME_HASH markPipelineCacheWithBuildTimestampHash = 2279843108;
constexpr const char* pMarkPipelineCacheWithBuildTimestampHashStr = "#2279843108";
constexpr DD_SETTINGS_NAME_HASH logTagIdMaskHash = 3402543442;
constexpr const char* pLogTagIdMaskHashStr = "#3402543442";
constexpr DD_SETTINGS_NAME_HASH pipelineFastCompileModeHash = 601804157;
constexpr const char* pPipelineFastCompileModeHashStr = "#601804157";
constexpr DD_SETTINGS_NAME_HASH pipelineLinkOptimizationModeHash = 278398877;
constexpr const char* pPipelineLinkOptimizationModeHashStr = "#278398877";
constexpr DD_SETTINGS_NAME_HASH pipelineLayoutModeHash = 1146964070;
constexpr const char* pPipelineLayoutModeHashStr = "#1146964070";
constexpr DD_SETTINGS_NAME_HASH pipelineLayoutSchemeSelectionStrategyHash = 626610365;
constexpr const char* pPipelineLayoutSchemeSelectionStrategyHashStr = "#626610365";
constexpr DD_SETTINGS_NAME_HASH pipelineLayoutPushConstantCompatibilityCheckHash = 371848649;
constexpr const char* pPipelineLayoutPushConstantCompatibilityCheckHashStr = "#371848649";
constexpr DD_SETTINGS_NAME_HASH pipelineBinningModeHash = 1967427837;
constexpr const char* pPipelineBinningModeHashStr = "#1967427837";
constexpr DD_SETTINGS_NAME_HASH disableBinningPsKillHash = 1197165395;
constexpr const char* pDisableBinningPsKillHashStr = "#1197165395";
constexpr DD_SETTINGS_NAME_HASH binningMaxPrimPerBatchHash = 1317079767;
constexpr const char* pBinningMaxPrimPerBatchHashStr = "#1317079767";
constexpr DD_SETTINGS_NAME_HASH binningContextStatesPerBinHash = 1661639333;
constexpr const char* pBinningContextStatesPerBinHashStr = "#1661639333";
constexpr DD_SETTINGS_NAME_HASH binningPersistentStatesPerBinHash = 850748547;
constexpr const char* pBinningPersistentStatesPerBinHashStr = "#850748547";
constexpr DD_SETTINGS_NAME_HASH binningOverridePbbForMrtHash = 2056111132;
constexpr const char* pBinningOverridePbbForMrtHashStr = "#2056111132";
constexpr DD_SETTINGS_NAME_HASH pipelineUseProfileHashAsClientHashHash = 3384165644;
constexpr const char* pPipelineUseProfileHashAsClientHashHashStr = "#3384165644";
constexpr DD_SETTINGS_NAME_HASH pipelineUseShaderHashAsProfileHashHash = 390173032;
constexpr const char* pPipelineUseShaderHashAsProfileHashHashStr = "#390173032";
constexpr DD_SETTINGS_NAME_HASH enablePipelineProfileDumpingHash = 3336386569;
constexpr const char* pEnablePipelineProfileDumpingHashStr = "#3336386569";
constexpr DD_SETTINGS_NAME_HASH pipelineProfileDumpFileHash = 2090402492;
constexpr const char* pPipelineProfileDumpFileHashStr = "#2090402492";
constexpr DD_SETTINGS_NAME_HASH pipelineProfileRuntimeFileHash = 1286473046;
constexpr const char* pPipelineProfileRuntimeFileHashStr = "#1286473046";
constexpr DD_SETTINGS_NAME_HASH pipelineProfileDbgPrintProfileMatchHash = 3578410736;
constexpr const char* pPipelineProfileDbgPrintProfileMatchHashStr = "#3578410736";
constexpr DD_SETTINGS_NAME_HASH pipelineProfileIgnoresAppProfileHash = 284988527;
constexpr const char* pPipelineProfileIgnoresAppProfileHashStr = "#284988527";
constexpr DD_SETTINGS_NAME_HASH pipelineProfileHaltOnParseFailureHash = 2803779161;
constexpr const char* pPipelineProfileHaltOnParseFailureHashStr = "#2803779161";
#if VKI_BUILD_GFX11
constexpr DD_SETTINGS_NAME_HASH enableImageMsaaLoadOptHash = 3737211822;
constexpr const char* pEnableImageMsaaLoadOptHashStr = "#3737211822";
#endif
constexpr DD_SETTINGS_NAME_HASH disableLoopUnrollsHash = 4129894350;
constexpr const char* pDisableLoopUnrollsHashStr = "#4129894350";
constexpr DD_SETTINGS_NAME_HASH disableEmbedConstArraysHash = 3897517765;
constexpr const char* pDisableEmbedConstArraysHashStr = "#3897517765";
constexpr DD_SETTINGS_NAME_HASH forceDepthClampBasedOnZExportHash = 3142289682;
constexpr const char* pForceDepthClampBasedOnZExportHashStr = "#3142289682";
constexpr DD_SETTINGS_NAME_HASH ignoreFlagFailOnPipelineCompileRequiredHash = 2007268106;
constexpr const char* pIgnoreFlagFailOnPipelineCompileRequiredHashStr = "#2007268106";
constexpr DD_SETTINGS_NAME_HASH dynamicPrimitiveTopologyUnrestrictedHash = 1131182512;
constexpr const char* pDynamicPrimitiveTopologyUnrestrictedHashStr = "#1131182512";
constexpr DD_SETTINGS_NAME_HASH useShaderLibraryForPipelineLibraryFastLinkHash = 809164442;
constexpr const char* pUseShaderLibraryForPipelineLibraryFastLinkHashStr = "#809164442";
constexpr DD_SETTINGS_NAME_HASH forceLinkTimeOptimizationInShaderObjectHash = 2678824197;
constexpr const char* pForceLinkTimeOptimizationInShaderObjectHashStr = "#2678824197";
constexpr DD_SETTINGS_NAME_HASH fullScreenFrameMetadataSupportHash = 3732619335;
constexpr const char* pFullScreenFrameMetadataSupportHashStr = "#3732619335";
constexpr DD_SETTINGS_NAME_HASH useSdmaCompositingBltHash = 1167844307;
constexpr const char* pUseSdmaCompositingBltHashStr = "#1167844307";
constexpr DD_SETTINGS_NAME_HASH enableAcquireBeforeSignalHash = 129319645;
constexpr const char* pEnableAcquireBeforeSignalHashStr = "#129319645";
constexpr DD_SETTINGS_NAME_HASH ignoreSuboptimalSwapchainSizeHash = 1182231700;
constexpr const char* pIgnoreSuboptimalSwapchainSizeHashStr = "#1182231700";
constexpr DD_SETTINGS_NAME_HASH forceMinImageCountHash = 2125809300;
constexpr const char* pForceMinImageCountHashStr = "#2125809300";
#if defined(_WIN32)
constexpr DD_SETTINGS_NAME_HASH dxgiPresentHash = 2621990464;
constexpr const char* pDxgiPresentHashStr = "#2621990464";
#endif
#if defined(_WIN32)
constexpr DD_SETTINGS_NAME_HASH dxgiSettingsHash = 1287584188;
constexpr const char* pDxgiSettingsHashStr = "#1287584188";
#endif
constexpr DD_SETTINGS_NAME_HASH enableRelocatableShadersHash = 370092524;
constexpr const char* pEnableRelocatableShadersHashStr = "#370092524";
constexpr DD_SETTINGS_NAME_HASH forcePerComponentFetchForUnalignedVbFormatHash = 1070359149;
constexpr const char* pForcePerComponentFetchForUnalignedVbFormatHashStr = "#1070359149";
constexpr DD_SETTINGS_NAME_HASH enableUberFetchShaderHash = 799334815;
constexpr const char* pEnableUberFetchShaderHashStr = "#799334815";
constexpr DD_SETTINGS_NAME_HASH enableEarlyCompileHash = 3433009662;
constexpr const char* pEnableEarlyCompileHashStr = "#3433009662";
constexpr DD_SETTINGS_NAME_HASH deferCompileOptimizedPipelineHash = 587372551;
constexpr const char* pDeferCompileOptimizedPipelineHashStr = "#587372551";
constexpr DD_SETTINGS_NAME_HASH deferCompileThreadCountHash = 3889087271;
constexpr const char* pDeferCompileThreadCountHashStr = "#3889087271";
constexpr DD_SETTINGS_NAME_HASH disablePerCompFetchHash = 3053501839;
constexpr const char* pDisablePerCompFetchHashStr = "#3053501839";
constexpr DD_SETTINGS_NAME_HASH disablePerInstanceFetchHash = 2340866811;
constexpr const char* pDisablePerInstanceFetchHashStr = "#2340866811";
constexpr DD_SETTINGS_NAME_HASH disableInstanceDivisorOptHash = 2443399743;
constexpr const char* pDisableInstanceDivisorOptHashStr = "#2443399743";
constexpr DD_SETTINGS_NAME_HASH forceAlignedForDynamicStrideHash = 2515568425;
constexpr const char* pForceAlignedForDynamicStrideHashStr = "#2515568425";
constexpr DD_SETTINGS_NAME_HASH supportPatchSpecConstHash = 818269424;
constexpr const char* pSupportPatchSpecConstHashStr = "#818269424";
constexpr DD_SETTINGS_NAME_HASH enablePipelineDumpHash = 809818814;
constexpr const char* pEnablePipelineDumpHashStr = "#809818814";
constexpr DD_SETTINGS_NAME_HASH pipelineDumpDirHash = 989712612;
constexpr const char* pPipelineDumpDirHashStr = "#989712612";
constexpr DD_SETTINGS_NAME_HASH appendExeNameToPipelineDumpHash = 746531377;
constexpr const char* pAppendExeNameToPipelineDumpHashStr = "#746531377";
constexpr DD_SETTINGS_NAME_HASH enableLogHash = 4062912068;
constexpr const char* pEnableLogHashStr = "#4062912068";
constexpr DD_SETTINGS_NAME_HASH logFileNameHash = 1494398452;
constexpr const char* pLogFileNameHashStr = "#1494398452";
constexpr DD_SETTINGS_NAME_HASH enableDebugHash = 4049167417;
constexpr const char* pEnableDebugHashStr = "#4049167417";
constexpr DD_SETTINGS_NAME_HASH debugLogFileNameHash = 2699235047;
constexpr const char* pDebugLogFileNameHashStr = "#2699235047";
constexpr DD_SETTINGS_NAME_HASH shaderReplaceModeHash = 3527127795;
constexpr const char* pShaderReplaceModeHashStr = "#3527127795";
constexpr DD_SETTINGS_NAME_HASH shaderReplaceDirHash = 3308298423;
constexpr const char* pShaderReplaceDirHashStr = "#3308298423";
constexpr DD_SETTINGS_NAME_HASH shaderReplacePipelineHashesHash = 907814690;
constexpr const char* pShaderReplacePipelineHashesHashStr = "#907814690";
constexpr DD_SETTINGS_NAME_HASH enableDropPipelineBinaryInstHash = 3273095844;
constexpr const char* pEnableDropPipelineBinaryInstHashStr = "#3273095844";
constexpr DD_SETTINGS_NAME_HASH subgroupSizeHash = 1216748277;
constexpr const char* pSubgroupSizeHashStr = "#1216748277";
constexpr DD_SETTINGS_NAME_HASH taskWaveSizeHash = 4241132668;
constexpr const char* pTaskWaveSizeHashStr = "#4241132668";
constexpr DD_SETTINGS_NAME_HASH vsWaveSizeHash = 2875804878;
constexpr const char* pVsWaveSizeHashStr = "#2875804878";
constexpr DD_SETTINGS_NAME_HASH tcsWaveSizeHash = 1234081121;
constexpr const char* pTcsWaveSizeHashStr = "#1234081121";
constexpr DD_SETTINGS_NAME_HASH tesWaveSizeHash = 3072096235;
constexpr const char* pTesWaveSizeHashStr = "#3072096235";
constexpr DD_SETTINGS_NAME_HASH gsWaveSizeHash = 105228583;
constexpr const char* pGsWaveSizeHashStr = "#105228583";
constexpr DD_SETTINGS_NAME_HASH meshWaveSizeHash = 877946252;
constexpr const char* pMeshWaveSizeHashStr = "#877946252";
constexpr DD_SETTINGS_NAME_HASH fsWaveSizeHash = 818064926;
constexpr const char* pFsWaveSizeHashStr = "#818064926";
constexpr DD_SETTINGS_NAME_HASH csWaveSizeHash = 267990155;
constexpr const char* pCsWaveSizeHashStr = "#267990155";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtWaveSizeHash = 4220061515;
constexpr const char* pRtWaveSizeHashStr = "#4220061515";
#endif
constexpr DD_SETTINGS_NAME_HASH enableNggHash = 109876678;
constexpr const char* pEnableNggHashStr = "#109876678";
constexpr DD_SETTINGS_NAME_HASH nggForceCullingModeHash = 2975482237;
constexpr const char* pNggForceCullingModeHashStr = "#2975482237";
constexpr DD_SETTINGS_NAME_HASH nggCompactVertexHash = 912322566;
constexpr const char* pNggCompactVertexHashStr = "#912322566";
constexpr DD_SETTINGS_NAME_HASH nggAlwaysUsePrimShaderTableHash = 1338799096;
constexpr const char* pNggAlwaysUsePrimShaderTableHashStr = "#1338799096";
constexpr DD_SETTINGS_NAME_HASH nggBackfaceExponentHash = 3043623194;
constexpr const char* pNggBackfaceExponentHashStr = "#3043623194";
constexpr DD_SETTINGS_NAME_HASH nggSubgroupSizingHash = 2391406036;
constexpr const char* pNggSubgroupSizingHashStr = "#2391406036";
constexpr DD_SETTINGS_NAME_HASH nggPrimsPerSubgroupHash = 958458130;
constexpr const char* pNggPrimsPerSubgroupHashStr = "#958458130";
constexpr DD_SETTINGS_NAME_HASH nggVertsPerSubgroupHash = 2005944793;
constexpr const char* pNggVertsPerSubgroupHashStr = "#2005944793";
constexpr DD_SETTINGS_NAME_HASH nggEnableBackfaceCullingHash = 3428907318;
constexpr const char* pNggEnableBackfaceCullingHashStr = "#3428907318";
constexpr DD_SETTINGS_NAME_HASH nggEnableFrustumCullingHash = 1220820826;
constexpr const char* pNggEnableFrustumCullingHashStr = "#1220820826";
constexpr DD_SETTINGS_NAME_HASH nggEnableBoxFilterCullingHash = 1523650329;
constexpr const char* pNggEnableBoxFilterCullingHashStr = "#1523650329";
constexpr DD_SETTINGS_NAME_HASH nggEnableSphereCullingHash = 1275673699;
constexpr const char* pNggEnableSphereCullingHashStr = "#1275673699";
constexpr DD_SETTINGS_NAME_HASH nggEnableSmallPrimFilterHash = 2076615117;
constexpr const char* pNggEnableSmallPrimFilterHashStr = "#2076615117";
constexpr DD_SETTINGS_NAME_HASH nggEnableCullDistanceCullingHash = 1789457237;
constexpr const char* pNggEnableCullDistanceCullingHashStr = "#1789457237";
constexpr DD_SETTINGS_NAME_HASH disableNggCullingHash = 4106586763;
constexpr const char* pDisableNggCullingHashStr = "#4106586763";
constexpr DD_SETTINGS_NAME_HASH enableForwardProgressHash = 3285317740;
constexpr const char* pEnableForwardProgressHashStr = "#3285317740";
constexpr DD_SETTINGS_NAME_HASH enableWgpModeHash = 3525874863;
constexpr const char* pEnableWgpModeHashStr = "#3525874863";
constexpr DD_SETTINGS_NAME_HASH waveBreakSizeHash = 668198610;
constexpr const char* pWaveBreakSizeHashStr = "#668198610";
constexpr DD_SETTINGS_NAME_HASH dropPipelineBinaryInstTokenHash = 1682931540;
constexpr const char* pDropPipelineBinaryInstTokenHashStr = "#1682931540";
constexpr DD_SETTINGS_NAME_HASH dropPipelineBinaryInstSizeHash = 3265600022;
constexpr const char* pDropPipelineBinaryInstSizeHashStr = "#3265600022";
constexpr DD_SETTINGS_NAME_HASH enableSpvPerfOptimalHash = 892928116;
constexpr const char* pEnableSpvPerfOptimalHashStr = "#892928116";
constexpr DD_SETTINGS_NAME_HASH enableSpvValidationHash = 2156135806;
constexpr const char* pEnableSpvValidationHashStr = "#2156135806";
constexpr DD_SETTINGS_NAME_HASH optimizeTessFactorHash = 4213884992;
constexpr const char* pOptimizeTessFactorHashStr = "#4213884992";
constexpr DD_SETTINGS_NAME_HASH zeroInitIlRegsHash = 1543960683;
constexpr const char* pZeroInitIlRegsHashStr = "#1543960683";
constexpr DD_SETTINGS_NAME_HASH skipUnsupportedOpCodeHash = 1161817703;
constexpr const char* pSkipUnsupportedOpCodeHashStr = "#1161817703";
constexpr DD_SETTINGS_NAME_HASH relaxedPrecisionFlagsHash = 2059818571;
constexpr const char* pRelaxedPrecisionFlagsHashStr = "#2059818571";
constexpr DD_SETTINGS_NAME_HASH llpcOptionsHash = 3508213626;
constexpr const char* pLlpcOptionsHashStr = "#3508213626";
constexpr DD_SETTINGS_NAME_HASH shaderCacheModeHash = 1113140201;
constexpr const char* pShaderCacheModeHashStr = "#1113140201";
constexpr DD_SETTINGS_NAME_HASH dropPipelineBinaryInstMaskHash = 4084890811;
constexpr const char* pDropPipelineBinaryInstMaskHashStr = "#4084890811";
constexpr DD_SETTINGS_NAME_HASH usePalPipelineCachingHash = 92824420;
constexpr const char* pUsePalPipelineCachingHashStr = "#92824420";
constexpr DD_SETTINGS_NAME_HASH enableInternalPipelineCachingToDiskHash = 2942305682;
constexpr const char* pEnableInternalPipelineCachingToDiskHashStr = "#2942305682";
constexpr DD_SETTINGS_NAME_HASH allowExternalPipelineCacheObjectHash = 2565610768;
constexpr const char* pAllowExternalPipelineCacheObjectHashStr = "#2565610768";
constexpr DD_SETTINGS_NAME_HASH usePipelineCacheInitialDataHash = 289054380;
constexpr const char* pUsePipelineCacheInitialDataHashStr = "#289054380";
constexpr DD_SETTINGS_NAME_HASH pipelineCachingEnvironmentVariableHash = 812278617;
constexpr const char* pPipelineCachingEnvironmentVariableHashStr = "#812278617";
constexpr DD_SETTINGS_NAME_HASH usePipelineCachingDefaultLocationHash = 823134843;
constexpr const char* pUsePipelineCachingDefaultLocationHashStr = "#823134843";
constexpr DD_SETTINGS_NAME_HASH pipelineCachingDefaultLocationHash = 3551643726;
constexpr const char* pPipelineCachingDefaultLocationHashStr = "#3551643726";
constexpr DD_SETTINGS_NAME_HASH pipelineCacheDefaultLocationLimitationHash = 3573714323;
constexpr const char* pPipelineCacheDefaultLocationLimitationHashStr = "#3573714323";
constexpr DD_SETTINGS_NAME_HASH allowCleanUpCacheDirectoryHash = 705214539;
constexpr const char* pAllowCleanUpCacheDirectoryHashStr = "#705214539";
constexpr DD_SETTINGS_NAME_HASH thresholdOfCleanUpCacheHash = 1862955411;
constexpr const char* pThresholdOfCleanUpCacheHashStr = "#1862955411";
constexpr DD_SETTINGS_NAME_HASH pipelineCacheCompressionHash = 558572679;
constexpr const char* pPipelineCacheCompressionHashStr = "#558572679";
constexpr DD_SETTINGS_NAME_HASH pipelineCacheUseHighCompressionHash = 2613165096;
constexpr const char* pPipelineCacheUseHighCompressionHashStr = "#2613165096";
constexpr DD_SETTINGS_NAME_HASH filterPipelineDumpByTypeHash = 3474328038;
constexpr const char* pFilterPipelineDumpByTypeHashStr = "#3474328038";
constexpr DD_SETTINGS_NAME_HASH filterPipelineDumpByHashHash = 579619034;
constexpr const char* pFilterPipelineDumpByHashHashStr = "#579619034";
constexpr DD_SETTINGS_NAME_HASH dumpPipelineWithApiHashHash = 1889558343;
constexpr const char* pDumpPipelineWithApiHashHashStr = "#1889558343";
constexpr DD_SETTINGS_NAME_HASH dumpDuplicatePipelinesHash = 785467391;
constexpr const char* pDumpDuplicatePipelinesHashStr = "#785467391";
constexpr DD_SETTINGS_NAME_HASH dumpPipelineCompileCacheMatrixHash = 4204527369;
constexpr const char* pDumpPipelineCompileCacheMatrixHashStr = "#4204527369";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH llpcRaytracingModeHash = 2377951393;
constexpr const char* pLlpcRaytracingModeHashStr = "#2377951393";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH cpsFlagsHash = 1376017734;
constexpr const char* pCpsFlagsHashStr = "#1376017734";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtInternalPipelineSpvPassMaskHash = 1770608086;
constexpr const char* pRtInternalPipelineSpvPassMaskHashStr = "#1770608086";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTraceRayCounterModeHash = 3345698643;
constexpr const char* pRtTraceRayCounterModeHashStr = "#3345698643";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtThreadGroupSizeXHash = 1617860441;
constexpr const char* pRtThreadGroupSizeXHashStr = "#1617860441";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtThreadGroupSizeYHash = 1601082822;
constexpr const char* pRtThreadGroupSizeYHashStr = "#1601082822";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtThreadGroupSizeZHash = 1584305203;
constexpr const char* pRtThreadGroupSizeZHashStr = "#1584305203";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtFlattenThreadGroupSizeHash = 2011398667;
constexpr const char* pRtFlattenThreadGroupSizeHashStr = "#2011398667";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtProfileMaxIterationHash = 560687145;
constexpr const char* pRtProfileMaxIterationHashStr = "#560687145";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTraceRayProfileFlagsHash = 3979483840;
constexpr const char* pRtTraceRayProfileFlagsHashStr = "#3979483840";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtMaxRayRecursionDepthHash = 500691136;
constexpr const char* pRtMaxRayRecursionDepthHashStr = "#500691136";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtIndirectStageMaskHash = 19114933;
constexpr const char* pRtIndirectStageMaskHashStr = "#19114933";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCallTargetOccupancyPerSimdHash = 3530078083;
constexpr const char* pIndirectCallTargetOccupancyPerSimdHashStr = "#3530078083";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtUnifiedVgprLimitHash = 1701464009;
constexpr const char* pRtUnifiedVgprLimitHashStr = "#1701464009";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableNodePointerFlagsHash = 1736152368;
constexpr const char* pRtEnableNodePointerFlagsHashStr = "#1736152368";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH boxSortingHeuristicHash = 3911830286;
constexpr const char* pBoxSortingHeuristicHashStr = "#3911830286";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtFp16BoxNodesInBlasModeHash = 870666470;
constexpr const char* pRtFp16BoxNodesInBlasModeHashStr = "#870666470";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH fp16BoxNodesRequireCompactionFlagHash = 3245287598;
constexpr const char* pFp16BoxNodesRequireCompactionFlagHashStr = "#3245287598";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtAllowFp16BoxNodesInUpdatableBvhHash = 1041663586;
constexpr const char* pRtAllowFp16BoxNodesInUpdatableBVHHashStr = "#1041663586";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtFp16BoxNodesInBlasModeMixedThresholdHash = 471261412;
constexpr const char* pRtFp16BoxNodesInBlasModeMixedThresholdHashStr = "#471261412";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableTopDownBuildHash = 999036545;
constexpr const char* pRtEnableTopDownBuildHashStr = "#999036545";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableTreeRebraidHash = 3604702553;
constexpr const char* pRtEnableTreeRebraidHashStr = "#3604702553";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxTopDownBuildInstancesHash = 3176477220;
constexpr const char* pMaxTopDownBuildInstancesHashStr = "#3176477220";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableTriangleSplittingHash = 3317010836;
constexpr const char* pRtEnableTriangleSplittingHashStr = "#3317010836";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTriangleSplittingFactorHash = 649536878;
constexpr const char* pRtTriangleSplittingFactorHashStr = "#649536878";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTriangleSplittingBudgetPerTriangleHash = 2706361595;
constexpr const char* pRtTriangleSplittingBudgetPerTriangleHashStr = "#2706361595";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTriangleSplittingPriorityHash = 1259710113;
constexpr const char* pRtTriangleSplittingPriorityHashStr = "#1259710113";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableMergedEncodeBuildHash = 185197740;
constexpr const char* pEnableMergedEncodeBuildHashStr = "#185197740";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableMergedEncodeUpdateHash = 2737560301;
constexpr const char* pEnableMergedEncodeUpdateHashStr = "#2737560301";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableMortonCode30Hash = 2322774569;
constexpr const char* pRtEnableMortonCode30HashStr = "#2322774569";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableVariableBitsMortonCodesHash = 3212320433;
constexpr const char* pEnableVariableBitsMortonCodesHashStr = "#3212320433";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnablePrefixScanDlbHash = 3033163953;
constexpr const char* pRtEnablePrefixScanDLBHashStr = "#3033163953";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTriangleCompressionAutoModeHash = 1864051375;
constexpr const char* pRtTriangleCompressionAutoModeHashStr = "#1864051375";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtCompileModeHash = 2087264323;
constexpr const char* pRtCompileModeHashStr = "#2087264323";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxUnifiedRayGenShadersHash = 4286721691;
constexpr const char* pMaxUnifiedRayGenShadersHashStr = "#4286721691";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxUnifiedNonRayGenShadersHash = 2505635556;
constexpr const char* pMaxUnifiedNonRayGenShadersHashStr = "#2505635556";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxTotalSizeOfUnifiedShadersHash = 775696901;
constexpr const char* pMaxTotalSizeOfUnifiedShadersHashStr = "#775696901";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH ldsStackSizeVsSpillingRatioHash = 1111816997;
constexpr const char* pLdsStackSizeVsSpillingRatioHashStr = "#1111816997";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH ldsStackSizeHash = 1943182019;
constexpr const char* pLdsStackSizeHashStr = "#1943182019";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableLdsSpillingHash = 504613017;
constexpr const char* pEnableLdsSpillingHashStr = "#504613017";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableOptimalLdsStackSizeForUnifiedHash = 2042743017;
constexpr const char* pEnableOptimalLdsStackSizeForUnifiedHashStr = "#2042743017";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableOptimalLdsStackSizeForIndirectHash = 3520841571;
constexpr const char* pEnableOptimalLdsStackSizeForIndirectHashStr = "#3520841571";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableBvhBuildDebugCountersHash = 639196656;
constexpr const char* pEnableBVHBuildDebugCountersHashStr = "#639196656";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableInsertBarriersInBuildAsHash = 2438791644;
constexpr const char* pEnableInsertBarriersInBuildASHashStr = "#2438791644";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableUniformNoReturnHash = 419612531;
constexpr const char* pEnableUniformNoReturnHashStr = "#419612531";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableReducedLinkageOptHash = 2599437376;
constexpr const char* pEnableReducedLinkageOptHashStr = "#2599437376";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH forceUseSpillTableForRayTracingPipelineLayoutsHash = 1486098315;
constexpr const char* pForceUseSpillTableForRayTracingPipelineLayoutsHashStr = "#1486098315";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTriangleCompressionModeHash = 2391262712;
constexpr const char* pRtTriangleCompressionModeHashStr = "#2391262712";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enablePairCompressionCostCheckHash = 882993887;
constexpr const char* pEnablePairCompressionCostCheckHashStr = "#882993887";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtBvhBuildModeOverrideHash = 1816782740;
constexpr const char* pRtBvhBuildModeOverrideHashStr = "#1816782740";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH bvhBuildModeOverrideBlasHash = 490809872;
constexpr const char* pBvhBuildModeOverrideBLASHashStr = "#490809872";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH bvhBuildModeOverrideTlasHash = 1588408410;
constexpr const char* pBvhBuildModeOverrideTLASHashStr = "#1588408410";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtBvhBuildModeDefaultHash = 3263640161;
constexpr const char* pRtBvhBuildModeDefaultHashStr = "#3263640161";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtBvhBuildModeFastTraceHash = 2719126487;
constexpr const char* pRtBvhBuildModeFastTraceHashStr = "#2719126487";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtBvhBuildModeFastBuildHash = 752863186;
constexpr const char* pRtBvhBuildModeFastBuildHashStr = "#752863186";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH disableRayTracingImageResourceTypeCheckHash = 289899022;
constexpr const char* pDisableRayTracingImageResourceTypeCheckHashStr = "#289899022";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxWavesPerCuHash = 1825573564;
constexpr const char* pMaxWavesPerCuHashStr = "#1825573564";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH maxThreadGroupsPerCuHash = 2095623888;
constexpr const char* pMaxThreadGroupsPerCuHashStr = "#2095623888";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH tgScheduleCountPerCuHash = 2740341843;
constexpr const char* pTgScheduleCountPerCuHashStr = "#2740341843";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH shaderInlineFlagsHash = 2892735388;
constexpr const char* pShaderInlineFlagsHashStr = "#2892735388";
#endif
constexpr DD_SETTINGS_NAME_HASH useUniversalAsComputeQueueHash = 3863259821;
constexpr const char* pUseUniversalAsComputeQueueHashStr = "#3863259821";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtBvhCpuBuildModeHash = 3030607088;
constexpr const char* pRtBvhCpuBuildModeHashStr = "#3030607088";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableUpdateParallelHash = 1691530778;
constexpr const char* pRtEnableUpdateParallelHashStr = "#1691530778";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableBuildParallelHash = 3367589243;
constexpr const char* pRtEnableBuildParallelHashStr = "#3367589243";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableFastLbvhHash = 3769541886;
constexpr const char* pRtEnableFastLBVHHashStr = "#3769541886";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH buildParallelWavesPerSimdHash = 3713696924;
constexpr const char* pBuildParallelWavesPerSimdHashStr = "#3713696924";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableAcquireReleaseInterfaceHash = 593107648;
constexpr const char* pRtEnableAcquireReleaseInterfaceHashStr = "#593107648";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableFusedInstanceNodeHash = 2736985558;
constexpr const char* pEnableFusedInstanceNodeHashStr = "#2736985558";
#endif
constexpr DD_SETTINGS_NAME_HASH dispatchRaysThreadGroupSizeHash = 1449537960;
constexpr const char* pDispatchRaysThreadGroupSizeHashStr = "#1449537960";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableBuildAccelStructStatsHash = 463622420;
constexpr const char* pRtEnableBuildAccelStructStatsHashStr = "#463622420";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCallConventionHash = 2354510336;
constexpr const char* pIndirectCallConventionHashStr = "#2354510336";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeRaygenHash = 599102039;
constexpr const char* pIndirectCalleeRaygenHashStr = "#599102039";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeMissHash = 3095324981;
constexpr const char* pIndirectCalleeMissHashStr = "#3095324981";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeClosestHitHash = 1837109597;
constexpr const char* pIndirectCalleeClosestHitHashStr = "#1837109597";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeAnyHitHash = 2973686646;
constexpr const char* pIndirectCalleeAnyHitHashStr = "#2973686646";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeIntersectionHash = 2985389076;
constexpr const char* pIndirectCalleeIntersectionHashStr = "#2985389076";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeCallableHash = 2033297517;
constexpr const char* pIndirectCalleeCallableHashStr = "#2033297517";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH indirectCalleeTraceRaysHash = 2385100319;
constexpr const char* pIndirectCalleeTraceRaysHashStr = "#2385100319";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH ignorePayloadLocationsHash = 2791783925;
constexpr const char* pIgnorePayloadLocationsHashStr = "#2791783925";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableRemapScratchBufferHash = 2862665477;
constexpr const char* pEnableRemapScratchBufferHashStr = "#2862665477";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableCompilePipelineLibraryHash = 1296218346;
constexpr const char* pRtEnableCompilePipelineLibraryHashStr = "#1296218346";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableAccelStructIndirectBuildHash = 3734997093;
constexpr const char* pRtEnableAccelStructIndirectBuildHashStr = "#3734997093";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableRayQueryCsSwizzleHash = 3982042812;
constexpr const char* pRtEnableRayQueryCsSwizzleHashStr = "#3982042812";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rayQueryCsSwizzleHash = 3244332899;
constexpr const char* pRayQueryCsSwizzleHashStr = "#3244332899";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableDispatchRaysOuterSwizzleHash = 3282538424;
constexpr const char* pRtEnableDispatchRaysOuterSwizzleHashStr = "#3282538424";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEnableDispatchRaysInnerSwizzleHash = 2492280841;
constexpr const char* pRtEnableDispatchRaysInnerSwizzleHashStr = "#2492280841";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtOuterTileSizeHash = 2462943899;
constexpr const char* pRtOuterTileSizeHashStr = "#2462943899";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableRaytracingSupportHash = 3081050319;
constexpr const char* pEnableRaytracingSupportHashStr = "#3081050319";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH emulatedRtIpLevelHash = 2455813629;
constexpr const char* pEmulatedRtIpLevelHashStr = "#2455813629";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rebraidLengthPercentageHash = 2508144782;
constexpr const char* pRebraidLengthPercentageHashStr = "#2508144782";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rebraidFactorHash = 1894916429;
constexpr const char* pRebraidFactorHashStr = "#1894916429";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH numMortonSizeBitsHash = 2104007441;
constexpr const char* pNumMortonSizeBitsHashStr = "#2104007441";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH plocRadiusHash = 2752838337;
constexpr const char* pPlocRadiusHashStr = "#2752838337";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtAutoSkipAabbIntersectionsHash = 1652478365;
constexpr const char* pRtAutoSkipAabbIntersectionsHashStr = "#1652478365";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtEmitRayTracingShaderDataTokenHash = 3826060220;
constexpr const char* pRtEmitRayTracingShaderDataTokenHashStr = "#3826060220";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableLdsFuncArgumentsHash = 1944395639;
constexpr const char* pEnableLdsFuncArgumentsHashStr = "#1944395639";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH disableAsCompatibilityCheckHash = 2448918999;
constexpr const char* pDisableASCompatibilityCheckHashStr = "#2448918999";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH batchBvhBuildsHash = 3368900888;
constexpr const char* pBatchBvhBuildsHashStr = "#3368900888";
#endif
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPostCmdEnableHash = 2908457448;
constexpr const char* pDbgBarrierPostCmdEnableHashStr = "#2908457448";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPostWaitPipePointHash = 156027798;
constexpr const char* pDbgBarrierPostWaitPipePointHashStr = "#156027798";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPostSignalPipePointHash = 895128045;
constexpr const char* pDbgBarrierPostSignalPipePointHashStr = "#895128045";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPostCacheSrcMaskHash = 1320062177;
constexpr const char* pDbgBarrierPostCacheSrcMaskHashStr = "#1320062177";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPostCacheDstMaskHash = 1231285864;
constexpr const char* pDbgBarrierPostCacheDstMaskHashStr = "#1231285864";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPreCmdEnableHash = 160975439;
constexpr const char* pDbgBarrierPreCmdEnableHashStr = "#160975439";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPreWaitPipePointHash = 3910150193;
constexpr const char* pDbgBarrierPreWaitPipePointHashStr = "#3910150193";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPreSignalPipePointHash = 2760693190;
constexpr const char* pDbgBarrierPreSignalPipePointHashStr = "#2760693190";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPreCacheSrcMaskHash = 1891812632;
constexpr const char* pDbgBarrierPreCacheSrcMaskHashStr = "#1891812632";
constexpr DD_SETTINGS_NAME_HASH dbgBarrierPreCacheDstMaskHash = 139905033;
constexpr const char* pDbgBarrierPreCacheDstMaskHashStr = "#139905033";
constexpr DD_SETTINGS_NAME_HASH forceNonUniformDescriptorIndexHash = 600436440;
constexpr const char* pForceNonUniformDescriptorIndexHashStr = "#600436440";
constexpr DD_SETTINGS_NAME_HASH resourceBarrierOptionsHash = 2348416782;
constexpr const char* pResourceBarrierOptionsHashStr = "#2348416782";
constexpr DD_SETTINGS_NAME_HASH barrierFilterOptionsHash = 3752069724;
constexpr const char* pBarrierFilterOptionsHashStr = "#3752069724";
constexpr DD_SETTINGS_NAME_HASH forceImageSharingModeHash = 1519675040;
constexpr const char* pForceImageSharingModeHashStr = "#1519675040";
constexpr DD_SETTINGS_NAME_HASH excessivePipelineCacheCountThresholdHash = 3723860598;
constexpr const char* pExcessivePipelineCacheCountThresholdHashStr = "#3723860598";
constexpr DD_SETTINGS_NAME_HASH expectedPipelineCacheEntriesHash = 2605429177;
constexpr const char* pExpectedPipelineCacheEntriesHashStr = "#2605429177";
constexpr DD_SETTINGS_NAME_HASH enumPreferredDeviceIndexHash = 3963167097;
constexpr const char* pEnumPreferredDeviceIndexHashStr = "#3963167097";
constexpr DD_SETTINGS_NAME_HASH robustBufferAccessHash = 3274333888;
constexpr const char* pRobustBufferAccessHashStr = "#3274333888";
constexpr DD_SETTINGS_NAME_HASH deprecateWave64Hash = 662688763;
constexpr const char* pDeprecateWave64HashStr = "#662688763";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableMergeSortHash = 3202547342;
constexpr const char* pEnableMergeSortHashStr = "#3202547342";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH numRebraidIterationsHash = 2370219876;
constexpr const char* pNumRebraidIterationsHashStr = "#2370219876";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rebraidQualityHeuristicTypeHash = 369802125;
constexpr const char* pRebraidQualityHeuristicTypeHashStr = "#369802125";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH fastBuildThresholdHash = 3470528280;
constexpr const char* pFastBuildThresholdHashStr = "#3470528280";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH enableEarlyPairCompressionHash = 3801489441;
constexpr const char* pEnableEarlyPairCompressionHashStr = "#3801489441";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH trianglePairingSearchRadiusHash = 552239229;
constexpr const char* pTrianglePairingSearchRadiusHashStr = "#552239229";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH lbvhBuildThresholdHash = 2497653766;
constexpr const char* pLbvhBuildThresholdHashStr = "#2497653766";
#endif
constexpr DD_SETTINGS_NAME_HASH rtIndirectVgprLimitHash = 2272596899;
constexpr const char* pRtIndirectVgprLimitHashStr = "#2272596899";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH forceRebuildForUpdatesHash = 1528658612;
constexpr const char* pForceRebuildForUpdatesHashStr = "#1528658612";
#endif
constexpr DD_SETTINGS_NAME_HASH lenientInstanceFuncQueryHash = 3810474515;
constexpr const char* pLenientInstanceFuncQueryHashStr = "#3810474515";
constexpr DD_SETTINGS_NAME_HASH appProfileDumpDirHash = 3218751138;
constexpr const char* pAppProfileDumpDirHashStr = "#3218751138";
constexpr DD_SETTINGS_NAME_HASH appProfileDumpMaskHash = 1605079959;
constexpr const char* pAppProfileDumpMaskHashStr = "#1605079959";
constexpr DD_SETTINGS_NAME_HASH optEnablePrtHash = 4176537453;
constexpr const char* pOptEnablePrtHashStr = "#4176537453";
constexpr DD_SETTINGS_NAME_HASH asyncComputeQueueMaxWavesPerCuHash = 2974072278;
constexpr const char* pAsyncComputeQueueMaxWavesPerCuHashStr = "#2974072278";
constexpr DD_SETTINGS_NAME_HASH asyncComputeQueueLimitHash = 1555805922;
constexpr const char* pAsyncComputeQueueLimitHashStr = "#1555805922";
constexpr DD_SETTINGS_NAME_HASH limitSampleCountsHash = 1858209418;
constexpr const char* pLimitSampleCountsHashStr = "#1858209418";
constexpr DD_SETTINGS_NAME_HASH alwaysReportHdrFormatsHash = 1653380104;
constexpr const char* pAlwaysReportHdrFormatsHashStr = "#1653380104";
constexpr DD_SETTINGS_NAME_HASH enableEmitSqttFunctionCrcHash = 1258924269;
constexpr const char* pEnableEmitSqttFunctionCrcHashStr = "#1258924269";
constexpr DD_SETTINGS_NAME_HASH disableImageResourceTypeCheckHash = 2304025916;
constexpr const char* pDisableImageResourceTypeCheckHashStr = "#2304025916";
constexpr DD_SETTINGS_NAME_HASH useOldDeviceUuidCalculationHash = 58342653;
constexpr const char* pUseOldDeviceUUIDCalculationHashStr = "#58342653";
constexpr DD_SETTINGS_NAME_HASH exposeLinearShadingRateImageHash = 2776046805;
constexpr const char* pExposeLinearShadingRateImageHashStr = "#2776046805";
constexpr DD_SETTINGS_NAME_HASH ignoreDeviceQueuePriorityFailuresHash = 1455662383;
constexpr const char* pIgnoreDeviceQueuePriorityFailuresHashStr = "#1455662383";
constexpr DD_SETTINGS_NAME_HASH forcePwsModeHash = 989867469;
constexpr const char* pForcePwsModeHashStr = "#989867469";
constexpr DD_SETTINGS_NAME_HASH enableMeshShadersHash = 967116483;
constexpr const char* pEnableMeshShadersHashStr = "#967116483";
constexpr DD_SETTINGS_NAME_HASH enableNative16BitTypesHash = 2689323866;
constexpr const char* pEnableNative16BitTypesHashStr = "#2689323866";
constexpr DD_SETTINGS_NAME_HASH memoryCustomDeviceAllocationCountLimitHash = 2849969415;
constexpr const char* pMemoryCustomDeviceAllocationCountLimitHashStr = "#2849969415";
constexpr DD_SETTINGS_NAME_HASH memoryBaseAddrAlignmentHash = 2939407841;
constexpr const char* pMemoryBaseAddrAlignmentHashStr = "#2939407841";
constexpr DD_SETTINGS_NAME_HASH memoryBaseAddrAlignmentCpuVisibleWin32Hash = 210525960;
constexpr const char* pMemoryBaseAddrAlignmentCpuVisibleWin32HashStr = "#210525960";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityDefaultHash = 289279007;
constexpr const char* pMemoryPriorityDefaultHashStr = "#289279007";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityImageAnyHash = 2321168839;
constexpr const char* pMemoryPriorityImageAnyHashStr = "#2321168839";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityImageShaderReadHash = 287215626;
constexpr const char* pMemoryPriorityImageShaderReadHashStr = "#287215626";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityImageShaderWriteHash = 3076300173;
constexpr const char* pMemoryPriorityImageShaderWriteHashStr = "#3076300173";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityImageColorTargetHash = 2285511511;
constexpr const char* pMemoryPriorityImageColorTargetHashStr = "#2285511511";
constexpr DD_SETTINGS_NAME_HASH memoryPriorityImageDepthStencilHash = 659226412;
constexpr const char* pMemoryPriorityImageDepthStencilHashStr = "#659226412";
constexpr DD_SETTINGS_NAME_HASH heapBudgetRatioOfHeapSizeLocalHash = 2165343898;
constexpr const char* pHeapBudgetRatioOfHeapSizeLocalHashStr = "#2165343898";
constexpr DD_SETTINGS_NAME_HASH heapBudgetRatioOfHeapSizeInvisibleHash = 2093136090;
constexpr const char* pHeapBudgetRatioOfHeapSizeInvisibleHashStr = "#2093136090";
constexpr DD_SETTINGS_NAME_HASH heapBudgetRatioOfHeapSizeNonlocalHash = 4014618225;
constexpr const char* pHeapBudgetRatioOfHeapSizeNonlocalHashStr = "#4014618225";
constexpr DD_SETTINGS_NAME_HASH transferGranularityUniversalOverrideHash = 1823255859;
constexpr const char* pTransferGranularityUniversalOverrideHashStr = "#1823255859";
constexpr DD_SETTINGS_NAME_HASH transferGranularityComputeOverrideHash = 335561107;
constexpr const char* pTransferGranularityComputeOverrideHashStr = "#335561107";
constexpr DD_SETTINGS_NAME_HASH memoryDeviceOverallocationAllowedHash = 3284038896;
constexpr const char* pMemoryDeviceOverallocationAllowedHashStr = "#3284038896";
constexpr DD_SETTINGS_NAME_HASH memoryDeviceOverallocationNonOverridableHash = 567133396;
constexpr const char* pMemoryDeviceOverallocationNonOverridableHashStr = "#567133396";
constexpr DD_SETTINGS_NAME_HASH transferGranularityDmaOverrideHash = 2375478640;
constexpr const char* pTransferGranularityDmaOverrideHashStr = "#2375478640";
constexpr DD_SETTINGS_NAME_HASH addMemoryPaddingToImageMemoryRequirementsHash = 2927276649;
constexpr const char* pAddMemoryPaddingToImageMemoryRequirementsHashStr = "#2927276649";
constexpr DD_SETTINGS_NAME_HASH memoryPaddingFactorForImageMemoryRequirementsHash = 2120879203;
constexpr const char* pMemoryPaddingFactorForImageMemoryRequirementsHashStr = "#2120879203";
constexpr DD_SETTINGS_NAME_HASH mallNoAllocResourcePolicyHash = 1220596479;
constexpr const char* pMallNoAllocResourcePolicyHashStr = "#1220596479";
constexpr DD_SETTINGS_NAME_HASH mallNoAllocCtPolicyHash = 276023972;
constexpr const char* pMallNoAllocCtPolicyHashStr = "#276023972";
constexpr DD_SETTINGS_NAME_HASH mallNoAllocSsrPolicyHash = 2492257589;
constexpr const char* pMallNoAllocSsrPolicyHashStr = "#2492257589";
constexpr DD_SETTINGS_NAME_HASH mallNoAllocDsPolicyHash = 660798618;
constexpr const char* pMallNoAllocDsPolicyHashStr = "#660798618";
constexpr DD_SETTINGS_NAME_HASH mallNoAllocCtSsrPolicyHash = 979258888;
constexpr const char* pMallNoAllocCtSsrPolicyHashStr = "#979258888";
constexpr DD_SETTINGS_NAME_HASH overrideHeapChoiceToLocalHash = 316940336;
constexpr const char* pOverrideHeapChoiceToLocalHashStr = "#316940336";
constexpr DD_SETTINGS_NAME_HASH overrideHeapChoiceToLocalBudgetHash = 1044815953;
constexpr const char* pOverrideHeapChoiceToLocalBudgetHashStr = "#1044815953";
constexpr DD_SETTINGS_NAME_HASH overrideHeapGartCacheableToUswcHash = 3043725378;
constexpr const char* pOverrideHeapGartCacheableToUswcHashStr = "#3043725378";
constexpr DD_SETTINGS_NAME_HASH overrideLocalHeapSizeInGBsHash = 3330621070;
constexpr const char* pOverrideLocalHeapSizeInGBsHashStr = "#3330621070";
constexpr DD_SETTINGS_NAME_HASH imageMemoryBudgetHash = 2681820168;
constexpr const char* pImageMemoryBudgetHashStr = "#2681820168";
constexpr DD_SETTINGS_NAME_HASH forceUmaHash = 263497521;
constexpr const char* pForceUMAHashStr = "#263497521";
constexpr DD_SETTINGS_NAME_HASH simulateExtDeviceMemoryReportHash = 3620564265;
constexpr const char* pSimulateExtDeviceMemoryReportHashStr = "#3620564265";
constexpr DD_SETTINGS_NAME_HASH simulateExtDeviceAddressBindingReportHash = 115455171;
constexpr const char* pSimulateExtDeviceAddressBindingReportHashStr = "#115455171";
constexpr DD_SETTINGS_NAME_HASH forceAppProfileEnableHash = 3513042023;
constexpr const char* pForceAppProfileEnableHashStr = "#3513042023";
constexpr DD_SETTINGS_NAME_HASH forceAppProfileValueHash = 2974380825;
constexpr const char* pForceAppProfileValueHashStr = "#2974380825";
constexpr DD_SETTINGS_NAME_HASH overrideUndefinedLayoutToTransferSrcOptimalHash = 1643155387;
constexpr const char* pOverrideUndefinedLayoutToTransferSrcOptimalHashStr = "#1643155387";
constexpr DD_SETTINGS_NAME_HASH preciseAnisoModeHash = 3851989621;
constexpr const char* pPreciseAnisoModeHashStr = "#3851989621";
constexpr DD_SETTINGS_NAME_HASH disableSingleMipAnisoOverrideHash = 2946818869;
constexpr const char* pDisableSingleMipAnisoOverrideHashStr = "#2946818869";
constexpr DD_SETTINGS_NAME_HASH useAnisoThresholdHash = 1273651387;
constexpr const char* pUseAnisoThresholdHashStr = "#1273651387";
constexpr DD_SETTINGS_NAME_HASH anisoThresholdHash = 3416866970;
constexpr const char* pAnisoThresholdHashStr = "#3416866970";
constexpr DD_SETTINGS_NAME_HASH samplerPerfMipHash = 3696903510;
constexpr const char* pSamplerPerfMipHashStr = "#3696903510";
constexpr DD_SETTINGS_NAME_HASH useFlipHintHash = 396475294;
constexpr const char* pUseFlipHintHashStr = "#396475294";
constexpr DD_SETTINGS_NAME_HASH ignorePreferredPresentModeHash = 1778509932;
constexpr const char* pIgnorePreferredPresentModeHashStr = "#1778509932";
constexpr DD_SETTINGS_NAME_HASH backgroundFullscreenPresentHash = 1298749675;
constexpr const char* pBackgroundFullscreenPresentHashStr = "#1298749675";
constexpr DD_SETTINGS_NAME_HASH backgroundFullscreenFailureDisableCountHash = 3304542337;
constexpr const char* pBackgroundFullscreenFailureDisableCountHashStr = "#3304542337";
constexpr DD_SETTINGS_NAME_HASH backgroundFullscreenSuccessResetCountHash = 253450729;
constexpr const char* pBackgroundFullscreenSuccessResetCountHashStr = "#253450729";
constexpr DD_SETTINGS_NAME_HASH backgroundFullscreenIgnorePresentErrorsHash = 3561218782;
constexpr const char* pBackgroundFullscreenIgnorePresentErrorsHashStr = "#3561218782";
constexpr DD_SETTINGS_NAME_HASH imageTilingOptModeHash = 356081981;
constexpr const char* pImageTilingOptModeHashStr = "#356081981";
constexpr DD_SETTINGS_NAME_HASH strictImageSizeRequirementsHash = 514061832;
constexpr const char* pStrictImageSizeRequirementsHashStr = "#514061832";
constexpr DD_SETTINGS_NAME_HASH imageTilingPreferenceHash = 2294620896;
constexpr const char* pImageTilingPreferenceHashStr = "#2294620896";
constexpr DD_SETTINGS_NAME_HASH imageTilingPreference3dGpuWritableHash = 2056294207;
constexpr const char* pImageTilingPreference3dGpuWritableHashStr = "#2056294207";
constexpr DD_SETTINGS_NAME_HASH enableFmaskBasedMsaaReadHash = 4238889853;
constexpr const char* pEnableFmaskBasedMsaaReadHashStr = "#4238889853";
constexpr DD_SETTINGS_NAME_HASH enableFmaskLookUpOptSampleIndexZeroHash = 2675634293;
constexpr const char* pEnableFmaskLookUpOptSampleIndexZeroHashStr = "#2675634293";
constexpr DD_SETTINGS_NAME_HASH enableHighPriorityDescriptorMemoryHash = 1370412112;
constexpr const char* pEnableHighPriorityDescriptorMemoryHashStr = "#1370412112";
constexpr DD_SETTINGS_NAME_HASH disableHtileBasedMsaaReadHash = 2924066334;
constexpr const char* pDisableHtileBasedMsaaReadHashStr = "#2924066334";
constexpr DD_SETTINGS_NAME_HASH disableMsaaStencilShaderReadHash = 839875998;
constexpr const char* pDisableMsaaStencilShaderReadHashStr = "#839875998";
constexpr DD_SETTINGS_NAME_HASH enableFullCopyDstOnlyHash = 3938418907;
constexpr const char* pEnableFullCopyDstOnlyHashStr = "#3938418907";
constexpr DD_SETTINGS_NAME_HASH optImgMaskToApplyShaderReadUsageForTransferSrcHash = 2934897062;
constexpr const char* pOptImgMaskToApplyShaderReadUsageForTransferSrcHashStr = "#2934897062";
constexpr DD_SETTINGS_NAME_HASH optImgMaskToApplyShaderWriteUsageForTransferDstHash = 4282216160;
constexpr const char* pOptImgMaskToApplyShaderWriteUsageForTransferDstHashStr = "#4282216160";
constexpr DD_SETTINGS_NAME_HASH optColorTargetUsageDoesNotContainResolveLayoutHash = 857693381;
constexpr const char* pOptColorTargetUsageDoesNotContainResolveLayoutHashStr = "#857693381";
constexpr DD_SETTINGS_NAME_HASH forceResolveLayoutForDepthStencilTransferUsageHash = 3801654136;
constexpr const char* pForceResolveLayoutForDepthStencilTransferUsageHashStr = "#3801654136";
constexpr DD_SETTINGS_NAME_HASH optRenderStateCacheEnableHash = 1237559792;
constexpr const char* pOptRenderStateCacheEnableHashStr = "#1237559792";
constexpr DD_SETTINGS_NAME_HASH ignoreMutableFlagHash = 669794809;
constexpr const char* pIgnoreMutableFlagHashStr = "#669794809";
constexpr DD_SETTINGS_NAME_HASH optimizeCmdbufModeHash = 3847566088;
constexpr const char* pOptimizeCmdbufModeHashStr = "#3847566088";
constexpr DD_SETTINGS_NAME_HASH prefetchShadersHash = 1791920096;
constexpr const char* pPrefetchShadersHashStr = "#1791920096";
constexpr DD_SETTINGS_NAME_HASH enableAceShaderPrefetchHash = 3859337367;
constexpr const char* pEnableAceShaderPrefetchHashStr = "#3859337367";
constexpr DD_SETTINGS_NAME_HASH dccBitsPerPixelThresholdHash = 2668340295;
constexpr const char* pDccBitsPerPixelThresholdHashStr = "#2668340295";
constexpr DD_SETTINGS_NAME_HASH forceEnableDccHash = 1123036035;
constexpr const char* pForceEnableDccHashStr = "#1123036035";
constexpr DD_SETTINGS_NAME_HASH disableSmallSurfColorCompressionSizeHash = 2075204220;
constexpr const char* pDisableSmallSurfColorCompressionSizeHashStr = "#2075204220";
constexpr DD_SETTINGS_NAME_HASH forceLowPrecisionDepthImageHash = 683393800;
constexpr const char* pForceLowPrecisionDepthImageHashStr = "#683393800";
constexpr DD_SETTINGS_NAME_HASH limitCbFetch256BHash = 3966060138;
constexpr const char* pLimitCbFetch256BHashStr = "#3966060138";
constexpr DD_SETTINGS_NAME_HASH useAcquireReleaseInterfaceHash = 1900171976;
constexpr const char* pUseAcquireReleaseInterfaceHashStr = "#1900171976";
constexpr DD_SETTINGS_NAME_HASH syncTokenEnabledHash = 651051092;
constexpr const char* pSyncTokenEnabledHashStr = "#651051092";
constexpr DD_SETTINGS_NAME_HASH enableSppHash = 2437981247;
constexpr const char* pEnableSPPHashStr = "#2437981247";
constexpr DD_SETTINGS_NAME_HASH enableD24S8Hash = 2449767571;
constexpr const char* pEnableD24S8HashStr = "#2449767571";
constexpr DD_SETTINGS_NAME_HASH disableDisplayDccHash = 1140473779;
constexpr const char* pDisableDisplayDccHashStr = "#1140473779";
constexpr DD_SETTINGS_NAME_HASH cpDmaCmdCopyMemoryMaxBytesHash = 1769412715;
constexpr const char* pCpDmaCmdCopyMemoryMaxBytesHashStr = "#1769412715";
constexpr DD_SETTINGS_NAME_HASH cmdBufBatchedSubmitChainLimitHash = 1627350093;
constexpr const char* pCmdBufBatchedSubmitChainLimitHashStr = "#1627350093";
constexpr DD_SETTINGS_NAME_HASH disableImplicitInvariantExportsHash = 237104671;
constexpr const char* pDisableImplicitInvariantExportsHashStr = "#237104671";
constexpr DD_SETTINGS_NAME_HASH disableForwardPropagateNoContractHash = 111873462;
constexpr const char* pDisableForwardPropagateNoContractHashStr = "#111873462";
constexpr DD_SETTINGS_NAME_HASH subpassLoadOpClearsBoundAttachmentsHash = 122127319;
constexpr const char* pSubpassLoadOpClearsBoundAttachmentsHashStr = "#122127319";
constexpr DD_SETTINGS_NAME_HASH renderPassClearUpfrontHash = 2865059039;
constexpr const char* pRenderPassClearUpfrontHashStr = "#2865059039";
constexpr DD_SETTINGS_NAME_HASH preBindDefaultStateHash = 2911412739;
constexpr const char* pPreBindDefaultStateHashStr = "#2911412739";
constexpr DD_SETTINGS_NAME_HASH forceCsThreadGroupSwizzleModeHash = 1488667282;
constexpr const char* pForceCsThreadGroupSwizzleModeHashStr = "#1488667282";
constexpr DD_SETTINGS_NAME_HASH forceCsThreadIdSwizzlingHash = 2499607500;
constexpr const char* pForceCsThreadIdSwizzlingHashStr = "#2499607500";
constexpr DD_SETTINGS_NAME_HASH overrideThreadGroupSizeXHash = 4220188667;
constexpr const char* pOverrideThreadGroupSizeXHashStr = "#4220188667";
constexpr DD_SETTINGS_NAME_HASH overrideThreadGroupSizeYHash = 4203411048;
constexpr const char* pOverrideThreadGroupSizeYHashStr = "#4203411048";
constexpr DD_SETTINGS_NAME_HASH overrideThreadGroupSizeZHash = 4253743905;
constexpr const char* pOverrideThreadGroupSizeZHashStr = "#4253743905";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH forceRtThreadGroupSwizzleModeHash = 3808503218;
constexpr const char* pForceRtThreadGroupSwizzleModeHashStr = "#3808503218";
#endif
constexpr DD_SETTINGS_NAME_HASH gfxInlinePushDescriptorUserDataLimitHash = 433606798;
constexpr const char* pGfxInlinePushDescriptorUserDataLimitHashStr = "#433606798";
constexpr DD_SETTINGS_NAME_HASH csInlinePushDescriptorUserDataLimitHash = 2398423927;
constexpr const char* pCsInlinePushDescriptorUserDataLimitHashStr = "#2398423927";
constexpr DD_SETTINGS_NAME_HASH enableAlternatingThreadGroupOrderHash = 2006642106;
constexpr const char* pEnableAlternatingThreadGroupOrderHashStr = "#2006642106";
constexpr DD_SETTINGS_NAME_HASH allowReZHash = 2462365247;
constexpr const char* pAllowReZHashStr = "#2462365247";
constexpr DD_SETTINGS_NAME_HASH disableDepthOnlyReZHash = 1089817907;
constexpr const char* pDisableDepthOnlyReZHashStr = "#1089817907";
constexpr DD_SETTINGS_NAME_HASH ac01WaNotNeededHash = 2153903514;
constexpr const char* pAc01WaNotNeededHashStr = "#2153903514";
constexpr DD_SETTINGS_NAME_HASH minColorAttachmentsForOptionalClearsHash = 1740290417;
constexpr const char* pMinColorAttachmentsForOptionalClearsHashStr = "#1740290417";
constexpr DD_SETTINGS_NAME_HASH minSubpassesForOptionalClearsHash = 1025834767;
constexpr const char* pMinSubpassesForOptionalClearsHashStr = "#1025834767";
constexpr DD_SETTINGS_NAME_HASH enableVariableRateShadingHash = 3826111010;
constexpr const char* pEnableVariableRateShadingHashStr = "#3826111010";
#if VKI_GPU_DECOMPRESS
constexpr DD_SETTINGS_NAME_HASH enableShaderDecodeHash = 2035919553;
constexpr const char* pEnableShaderDecodeHashStr = "#2035919553";
#endif
#if VKI_GPU_DECOMPRESS
constexpr DD_SETTINGS_NAME_HASH enableBc3EncoderHash = 2980865854;
constexpr const char* pEnableBC3EncoderHashStr = "#2980865854";
#endif
constexpr DD_SETTINGS_NAME_HASH devModeStartFrameDebugUtilsLabelHash = 1579501088;
constexpr const char* pDevModeStartFrameDebugUtilsLabelHashStr = "#1579501088";
constexpr DD_SETTINGS_NAME_HASH devModeEndFrameDebugUtilsLabelHash = 4275365257;
constexpr const char* pDevModeEndFrameDebugUtilsLabelHashStr = "#4275365257";
constexpr DD_SETTINGS_NAME_HASH devModeBlockingEndFrameDebugUtilsHash = 4132874978;
constexpr const char* pDevModeBlockingEndFrameDebugUtilsHashStr = "#4132874978";
constexpr DD_SETTINGS_NAME_HASH devModePipelineUriServicePostSizeLimitHash = 801344686;
constexpr const char* pDevModePipelineUriServicePostSizeLimitHashStr = "#801344686";
constexpr DD_SETTINGS_NAME_HASH devModeElfReplacementDirectoryEnableHash = 1051952064;
constexpr const char* pDevModeElfReplacementDirectoryEnableHashStr = "#1051952064";
constexpr DD_SETTINGS_NAME_HASH devModeElfReplacementDirectoryHash = 2986257399;
constexpr const char* pDevModeElfReplacementDirectoryHashStr = "#2986257399";
constexpr DD_SETTINGS_NAME_HASH devModeShaderIsaDbEnableHash = 3998535268;
constexpr const char* pDevModeShaderIsaDbEnableHashStr = "#3998535268";
constexpr DD_SETTINGS_NAME_HASH devModeQueueTimingEnableHash = 4267003511;
constexpr const char* pDevModeQueueTimingEnableHashStr = "#4267003511";
constexpr DD_SETTINGS_NAME_HASH devModeSqttMarkerEnableHash = 3758115926;
constexpr const char* pDevModeSqttMarkerEnableHashStr = "#3758115926";
constexpr DD_SETTINGS_NAME_HASH devModeSqttForceDisableHash = 1045260770;
constexpr const char* pDevModeSqttForceDisableHashStr = "#1045260770";
constexpr DD_SETTINGS_NAME_HASH devModeSqttWaitIdleHash = 2301549408;
constexpr const char* pDevModeSqttWaitIdleHashStr = "#2301549408";
constexpr DD_SETTINGS_NAME_HASH devModeSqttFlushAllQueuesHash = 4103072742;
constexpr const char* pDevModeSqttFlushAllQueuesHashStr = "#4103072742";
constexpr DD_SETTINGS_NAME_HASH devModeSqttGpuMemoryLimitHash = 1724659923;
constexpr const char* pDevModeSqttGpuMemoryLimitHashStr = "#1724659923";
constexpr DD_SETTINGS_NAME_HASH devModeSqttFrameCountHash = 1516028043;
constexpr const char* pDevModeSqttFrameCountHashStr = "#1516028043";
constexpr DD_SETTINGS_NAME_HASH devModeSqttTraceBeginEndTagEnableHash = 170815525;
constexpr const char* pDevModeSqttTraceBeginEndTagEnableHashStr = "#170815525";
constexpr DD_SETTINGS_NAME_HASH devModeSqttTraceBeginTagValueHash = 1843312060;
constexpr const char* pDevModeSqttTraceBeginTagValueHashStr = "#1843312060";
constexpr DD_SETTINGS_NAME_HASH devModeSqttTraceEndTagValueHash = 1382482956;
constexpr const char* pDevModeSqttTraceEndTagValueHashStr = "#1382482956";
constexpr DD_SETTINGS_NAME_HASH devModeSqttInstructionTraceEnableHash = 2498745445;
constexpr const char* pDevModeSqttInstructionTraceEnableHashStr = "#2498745445";
constexpr DD_SETTINGS_NAME_HASH devModeSqttTargetApiPsoHashHash = 3810870996;
constexpr const char* pDevModeSqttTargetApiPsoHashHashStr = "#3810870996";
constexpr DD_SETTINGS_NAME_HASH devModeSqttForceBlockOnTraceEndHash = 2293963252;
constexpr const char* pDevModeSqttForceBlockOnTraceEndHashStr = "#2293963252";
constexpr DD_SETTINGS_NAME_HASH devModeSqttPrepareFrameCountHash = 1904450154;
constexpr const char* pDevModeSqttPrepareFrameCountHashStr = "#1904450154";
constexpr DD_SETTINGS_NAME_HASH devModeEnableRgpTraceDumpHash = 1661897992;
constexpr const char* pDevModeEnableRgpTraceDumpHashStr = "#1661897992";
constexpr DD_SETTINGS_NAME_HASH devModeRgpTraceDumpFileHash = 2857865293;
constexpr const char* pDevModeRgpTraceDumpFileHashStr = "#2857865293";
constexpr DD_SETTINGS_NAME_HASH rgpInstTraceBarrierEnabledHash = 3531419539;
constexpr const char* pRgpInstTraceBarrierEnabledHashStr = "#3531419539";
constexpr DD_SETTINGS_NAME_HASH overrideShaderParamsHash = 15225846;
constexpr const char* pOverrideShaderParamsHashStr = "#15225846";
constexpr DD_SETTINGS_NAME_HASH overrideShaderHashUpperHash = 4034696060;
constexpr const char* pOverrideShaderHashUpperHashStr = "#4034696060";
constexpr DD_SETTINGS_NAME_HASH overrideShaderHashLowerHash = 951100197;
constexpr const char* pOverrideShaderHashLowerHashStr = "#951100197";
constexpr DD_SETTINGS_NAME_HASH overrideShaderStageHash = 205873806;
constexpr const char* pOverrideShaderStageHashStr = "#205873806";
constexpr DD_SETTINGS_NAME_HASH overrideNumVgprsAvailableHash = 2903928462;
constexpr const char* pOverrideNumVgprsAvailableHashStr = "#2903928462";
constexpr DD_SETTINGS_NAME_HASH overrideWavesPerCuHash = 297810728;
constexpr const char* pOverrideWavesPerCuHashStr = "#297810728";
constexpr DD_SETTINGS_NAME_HASH overrideUserDataSpillThresholdHash = 2769900547;
constexpr const char* pOverrideUserDataSpillThresholdHashStr = "#2769900547";
constexpr DD_SETTINGS_NAME_HASH overrideMaxLdsSpillDwordsHash = 1651396017;
constexpr const char* pOverrideMaxLdsSpillDwordsHashStr = "#1651396017";
constexpr DD_SETTINGS_NAME_HASH overrideDisableLoopUnrollsHash = 2077939830;
constexpr const char* pOverrideDisableLoopUnrollsHashStr = "#2077939830";
constexpr DD_SETTINGS_NAME_HASH overrideUseSiSchedulerHash = 995249705;
constexpr const char* pOverrideUseSiSchedulerHashStr = "#995249705";
constexpr DD_SETTINGS_NAME_HASH overrideReconfigWorkgroupLayoutHash = 3705509468;
constexpr const char* pOverrideReconfigWorkgroupLayoutHashStr = "#3705509468";
constexpr DD_SETTINGS_NAME_HASH overrideDisableLicmHash = 671488344;
constexpr const char* pOverrideDisableLicmHashStr = "#671488344";
constexpr DD_SETTINGS_NAME_HASH overrideEnableLoadScalarizerHash = 1667661998;
constexpr const char* pOverrideEnableLoadScalarizerHashStr = "#1667661998";
constexpr DD_SETTINGS_NAME_HASH overrideDisableCodeSinkingHash = 2891533743;
constexpr const char* pOverrideDisableCodeSinkingHashStr = "#2891533743";
constexpr DD_SETTINGS_NAME_HASH overrideAggressiveInvariantLoadsHash = 207917568;
constexpr const char* pOverrideAggressiveInvariantLoadsHashStr = "#207917568";
constexpr DD_SETTINGS_NAME_HASH overrideNsaThresholdHash = 3499186560;
constexpr const char* pOverrideNsaThresholdHashStr = "#3499186560";
constexpr DD_SETTINGS_NAME_HASH overrideForceLoopUnrollCountHash = 4203085353;
constexpr const char* pOverrideForceLoopUnrollCountHashStr = "#4203085353";
constexpr DD_SETTINGS_NAME_HASH overrideUnrollThresholdHash = 3468695440;
constexpr const char* pOverrideUnrollThresholdHashStr = "#3468695440";
constexpr DD_SETTINGS_NAME_HASH overrideFastMathFlagsHash = 1234474720;
constexpr const char* pOverrideFastMathFlagsHashStr = "#1234474720";
constexpr DD_SETTINGS_NAME_HASH overrideDisableFastMathFlagsHash = 931460246;
constexpr const char* pOverrideDisableFastMathFlagsHashStr = "#931460246";
constexpr DD_SETTINGS_NAME_HASH overrideFavorLatencyHidingHash = 593221256;
constexpr const char* pOverrideFavorLatencyHidingHashStr = "#593221256";
constexpr DD_SETTINGS_NAME_HASH overrideScalarizeWaterfallLoadsHash = 1619489114;
constexpr const char* pOverrideScalarizeWaterfallLoadsHashStr = "#1619489114";
constexpr DD_SETTINGS_NAME_HASH overrideBackwardPropagateNoContractHash = 3404738962;
constexpr const char* pOverrideBackwardPropagateNoContractHashStr = "#3404738962";
constexpr DD_SETTINGS_NAME_HASH overrideEnableSelectiveInlineHash = 4055394881;
constexpr const char* pOverrideEnableSelectiveInlineHashStr = "#4055394881";
constexpr DD_SETTINGS_NAME_HASH overrideEnableSubvectorHash = 2990483011;
constexpr const char* pOverrideEnableSubvectorHashStr = "#2990483011";
constexpr DD_SETTINGS_NAME_HASH overrideCsTgPerCuHash = 2898940541;
constexpr const char* pOverrideCsTgPerCuHashStr = "#2898940541";
constexpr DD_SETTINGS_NAME_HASH overrideUsePbbPerCrcHash = 2471901291;
constexpr const char* pOverrideUsePbbPerCrcHashStr = "#2471901291";
constexpr DD_SETTINGS_NAME_HASH overrideAllowReZHash = 2596394967;
constexpr const char* pOverrideAllowReZHashStr = "#2596394967";
constexpr DD_SETTINGS_NAME_HASH overrideWaveSizeHash = 311520325;
constexpr const char* pOverrideWaveSizeHashStr = "#311520325";
constexpr DD_SETTINGS_NAME_HASH overrideWgpModeHash = 4247168110;
constexpr const char* pOverrideWgpModeHashStr = "#4247168110";
constexpr DD_SETTINGS_NAME_HASH overrideUseNggHash = 3729959148;
constexpr const char* pOverrideUseNggHashStr = "#3729959148";
constexpr DD_SETTINGS_NAME_HASH overrideThreadGroupSwizzlingHash = 2247511209;
constexpr const char* pOverrideThreadGroupSwizzlingHashStr = "#2247511209";
constexpr DD_SETTINGS_NAME_HASH overrideThreadIdSwizzleHash = 1075184202;
constexpr const char* pOverrideThreadIdSwizzleHashStr = "#1075184202";
constexpr DD_SETTINGS_NAME_HASH eliminateFuncLoadStoreHash = 2427908486;
constexpr const char* pEliminateFuncLoadStoreHashStr = "#2427908486";
constexpr DD_SETTINGS_NAME_HASH modifyResourceKeyForAppProfileHash = 3386964081;
constexpr const char* pModifyResourceKeyForAppProfileHashStr = "#3386964081";
constexpr DD_SETTINGS_NAME_HASH resourceProfileIgnoresAppProfileHash = 3259709197;
constexpr const char* pResourceProfileIgnoresAppProfileHashStr = "#3259709197";
constexpr DD_SETTINGS_NAME_HASH overrideResourceParamsHash = 2494222459;
constexpr const char* pOverrideResourceParamsHashStr = "#2494222459";
constexpr DD_SETTINGS_NAME_HASH overrideResourceHashDimensionsHash = 3988943396;
constexpr const char* pOverrideResourceHashDimensionsHashStr = "#3988943396";
constexpr DD_SETTINGS_NAME_HASH overrideResourceHashCrcHash = 1371163493;
constexpr const char* pOverrideResourceHashCrcHashStr = "#1371163493";
constexpr DD_SETTINGS_NAME_HASH overrideResourceDccOnOffHash = 585965089;
constexpr const char* pOverrideResourceDccOnOffHashStr = "#585965089";
constexpr DD_SETTINGS_NAME_HASH vulkanTexFilterQualityHash = 3719285346;
constexpr const char* pVulkanTexFilterQualityHashStr = "#3719285346";
constexpr DD_SETTINGS_NAME_HASH appGpuIdHash = 330166207;
constexpr const char* pAppGpuIDHashStr = "#330166207";
constexpr DD_SETTINGS_NAME_HASH disableAmdVendorExtensionsHash = 1562569691;
constexpr const char* pDisableAMDVendorExtensionsHashStr = "#1562569691";
constexpr DD_SETTINGS_NAME_HASH alwaysAllocDynamicDescriptorDataHash = 3849278879;
constexpr const char* pAlwaysAllocDynamicDescriptorDataHashStr = "#3849278879";
constexpr DD_SETTINGS_NAME_HASH implicitExternalSynchronizationHash = 3041187323;
constexpr const char* pImplicitExternalSynchronizationHashStr = "#3041187323";
constexpr DD_SETTINGS_NAME_HASH overrideShaderThreadGroupSizeXHash = 3169822062;
constexpr const char* pOverrideShaderThreadGroupSizeXHashStr = "#3169822062";
constexpr DD_SETTINGS_NAME_HASH overrideShaderThreadGroupSizeYHash = 3186599681;
constexpr const char* pOverrideShaderThreadGroupSizeYHashStr = "#3186599681";
constexpr DD_SETTINGS_NAME_HASH overrideShaderThreadGroupSizeZHash = 3136266824;
constexpr const char* pOverrideShaderThreadGroupSizeZHashStr = "#3136266824";
constexpr DD_SETTINGS_NAME_HASH forceDisableAnisoFilterHash = 467563870;
constexpr const char* pForceDisableAnisoFilterHashStr = "#467563870";
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH forceInvalidAccelStructHash = 3054897996;
constexpr const char* pForceInvalidAccelStructHashStr = "#3054897996";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtTossPointHash = 3498664546;
constexpr const char* pRtTossPointHashStr = "#3498664546";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtMaxRayLengthHash = 948351573;
constexpr const char* pRtMaxRayLengthHashStr = "#948351573";
#endif
#if VKI_RAY_TRACING
constexpr DD_SETTINGS_NAME_HASH rtGpuDebugFlagsHash = 504838245;
constexpr const char* pRtGpuDebugFlagsHashStr = "#504838245";
#endif
constexpr DD_SETTINGS_NAME_HASH waitForDebuggerHash = 4063808744;
constexpr const char* pWaitForDebuggerHashStr = "#4063808744";
constexpr DD_SETTINGS_NAME_HASH waitForDebuggerExecutableNameHash = 1703200003;
constexpr const char* pWaitForDebuggerExecutableNameHashStr = "#1703200003";
constexpr DD_SETTINGS_NAME_HASH debugTimeoutHash = 4104331531;
constexpr const char* pDebugTimeoutHashStr = "#4104331531";
constexpr DD_SETTINGS_NAME_HASH waitAfterSubmitHash = 3700042626;
constexpr const char* pWaitAfterSubmitHashStr = "#3700042626";
constexpr DD_SETTINGS_NAME_HASH enableDebugPrintfHash = 410810230;
constexpr const char* pEnableDebugPrintfHashStr = "#410810230";
constexpr DD_SETTINGS_NAME_HASH debugPrintfBufferSizeHash = 2357310416;
constexpr const char* pDebugPrintfBufferSizeHashStr = "#2357310416";
constexpr DD_SETTINGS_NAME_HASH enableHangOutputHash = 569903983;
constexpr const char* pEnableHangOutputHashStr = "#569903983";
constexpr DD_SETTINGS_NAME_HASH debugPrintfDumpFolderHash = 2046176165;
constexpr const char* pDebugPrintfDumpFolderHashStr = "#2046176165";
constexpr DD_SETTINGS_NAME_HASH debugPrintfToStdoutHash = 3125557681;
constexpr const char* pDebugPrintfToStdoutHashStr = "#3125557681";
constexpr DD_SETTINGS_NAME_HASH supportMutableDescriptorsHash = 2157183692;
constexpr const char* pSupportMutableDescriptorsHashStr = "#2157183692";
constexpr DD_SETTINGS_NAME_HASH initializeVramToZeroHash = 3264907718;
constexpr const char* pInitializeVramToZeroHashStr = "#3264907718";
constexpr DD_SETTINGS_NAME_HASH vSyncControlHash = 3131504779;
constexpr const char* pVSyncControlHashStr = "#3131504779";
constexpr DD_SETTINGS_NAME_HASH disableTruncCoordForGatherHash = 1586831684;
constexpr const char* pDisableTruncCoordForGatherHashStr = "#1586831684";
constexpr DD_SETTINGS_NAME_HASH reportSuboptimalPresentAsOutOfDateHash = 2173438959;
constexpr const char* pReportSuboptimalPresentAsOutOfDateHashStr = "#2173438959";
constexpr DD_SETTINGS_NAME_HASH exportNvComputeShaderDerivativesHash = 3012338145;
constexpr const char* pExportNvComputeShaderDerivativesHashStr = "#3012338145";
constexpr DD_SETTINGS_NAME_HASH exportNvDeviceGeneratedCommandsHash = 2256216364;
constexpr const char* pExportNvDeviceGeneratedCommandsHashStr = "#2256216364";
constexpr DD_SETTINGS_NAME_HASH exportImageCompressionControlHash = 1823909671;
constexpr const char* pExportImageCompressionControlHashStr = "#1823909671";
constexpr DD_SETTINGS_NAME_HASH rpmViewsBypassMallHash = 2274774246;
constexpr const char* pRpmViewsBypassMallHashStr = "#2274774246";
constexpr DD_SETTINGS_NAME_HASH disable3dLinearImageFormatSupportHash = 1349255172;
constexpr const char* pDisable3dLinearImageFormatSupportHashStr = "#1349255172";
constexpr DD_SETTINGS_NAME_HASH skipUnMapMemoryHash = 1343774630;
constexpr const char* pSkipUnMapMemoryHashStr = "#1343774630";
constexpr DD_SETTINGS_NAME_HASH enableGraphicsPipelineLibrariesHash = 3367196772;
constexpr const char* pEnableGraphicsPipelineLibrariesHashStr = "#3367196772";
constexpr DD_SETTINGS_NAME_HASH enableColorClearAutoSyncHash = 2641310454;
constexpr const char* pEnableColorClearAutoSyncHashStr = "#2641310454";
constexpr DD_SETTINGS_NAME_HASH clampMaxImageSizeHash = 3316079846;
constexpr const char* pClampMaxImageSizeHashStr = "#3316079846";
// =======================================================================================
// SettingsBlob

class VulkanSettingsBlobNode : public DevDriver::SettingsBlobNode
{
public:
    const uint8_t* GetBlob(uint32_t* pOutSize) override;
    bool IsEncoded() override;
    uint32_t GetMagicOffset() override;
    uint64_t GetBlobHash() override;
};


} // vk

